#!/bin/bash

# Setup-Skript für ExpanderPiSetup
# Einbinden der Helper-Ressourcen
. /data/SetupHelper/HelperResources/forSetupScript

# Standardaktionen aktivieren
standardPromptAndActions='yes'

# Nicht-interaktiven Modus erkennen
nonInteractiveMode=false
if [ "${SETUPHELPER_NONINTERACTIVE:-}" != "" ]; then
    case "${SETUPHELPER_NONINTERACTIVE,,}" in
        1|true|yes|y|on)
            nonInteractiveMode=true
            ;;
    esac
fi
if [ "${SETUPHELPER_FORCE_NONINTERACTIVE:-}" != "" ]; then
    case "${SETUPHELPER_FORCE_NONINTERACTIVE,,}" in
        1|true|yes|y|on)
            nonInteractiveMode=true
            ;;
        0|false|no|n|off)
            nonInteractiveMode=false
            ;;
    esac
fi
if [ "${SETUPHELPER_MODE:-}" != "" ]; then
    case "${SETUPHELPER_MODE,,}" in
        batch|noninteractive)
            nonInteractiveMode=true
            ;;
    esac
fi
if [ "$nonInteractiveMode" = false ] && [ ! -t 0 ]; then
    nonInteractiveMode=true
fi
if [ "$nonInteractiveMode" = true ]; then
    logMessage "Nicht-interaktiver Modus erkannt. Benutzerabfragen werden übersprungen."
fi

# Installationsverzeichnis festlegen
ROOT_PATH=/data/ExpanderPiSetup

# Pfaddefinitionen
CONFIG_FILE="/etc/venus/dbus-adc.conf"
BACKUP_CONFIG_FILE="${CONFIG_FILE}.orig"
SOURCE_FILE_DIR="${ROOT_PATH}/FileSets"
OVERLAYS=("i2c-rtc.dtbo" "ds1307-rtc.dtbo" "mcp3208.dtbo")
OVERLAY_DIR="/u-boot/overlays"
OVERLAY_STATE_DIR="${ROOT_PATH}/overlay_state"
CONFIG_TXT="/u-boot/config.txt"
CONFIG_TXT_BACKUP="/u-boot/config.txt.orig"
REQUIRED_MODULES=("kernel-module-rtc-ds1307" "kernel-module-mcp320x")
MODULE_STATE_DIR="${ROOT_PATH}/state"
MODULE_TRACK_FILE="${MODULE_STATE_DIR}/installed_kernel_modules.list"
RC_LOCAL_STATE_FILE="${MODULE_STATE_DIR}/rc_local_entries.list"
RC_LOCAL_FILE="/data/rc.local"
RC_LOCAL_BACKUP="/data/rc.local.orig"
RC_LOCAL_CONTENT="echo ds1307 0x68 > /sys/class/i2c-adapter/i2c-1/new_device\nhwclock -s"
USER_CONFIG_FILE="${ROOT_PATH}/dbus-adc.user.conf"
DEFAULT_VREF_FALLBACK="1.3"
DEFAULT_SCALE_FALLBACK="4095"
DEFAULT_CHANNEL_TYPES_FALLBACK=("tank" "tank" "tank" "tank" "temp" "temp" "temp" "temp")
DEFAULT_CHANNEL_LABELS_FALLBACK=("tank" "tank" "tank" "tank" "temp" "temp" "temp" "temp")
TOTAL_ADC_CHANNELS=8
ADC_DEVICE_LINE="device iio:device0"

python_command=""

detect_python() {
    if [ -n "$python_command" ]; then
        return 0
    fi

    if command -v python3 >/dev/null 2>&1; then
        python_command="python3"
        return 0
    fi

    if command -v python >/dev/null 2>&1; then
        python_command="python"
        return 0
    fi

    return 1
}

load_gui_configuration() {
    if ! detect_python; then
        return 1
    fi

    local python_output
    python_output="$("$python_command" <<'PY'
import shlex
import sys

try:
    import dbus
except Exception:
    sys.exit(1)

service = "com.victronenergy.settings"
root = "/Settings/ExpanderPi/DbusAdc"

bus = dbus.SystemBus()

def get_value(path):
    try:
        obj = bus.get_object(service, path)
        value = obj.GetValue(dbus_interface="com.victronenergy.BusItem")
    except Exception:
        return ""

    if value is None:
        return ""

    if isinstance(value, (dbus.Double, dbus.Int32, dbus.Int64, dbus.UInt32, dbus.UInt64)):
        return str(value)

    return str(value)

values = {}
values["EXPANDERPI_VREF"] = get_value(root + "/Vref")
values["EXPANDERPI_SCALE"] = get_value(root + "/Scale")

for idx in range(8):
    base = f"{root}/Channel{idx}"
    values[f"EXPANDERPI_CHANNEL_{idx}_TYPE"] = get_value(base + "/Type")
    values[f"EXPANDERPI_CHANNEL_{idx}_LABEL"] = get_value(base + "/Label")

if not any(values.values()):
    sys.exit(1)

for key, val in values.items():
    print(f"{key}={shlex.quote(val)}")
PY
)" || return 1

    if [ -z "$python_output" ]; then
        return 1
    fi

    eval "$python_output"
    return 0
}

parse_default_adc_configuration() {
    local template_file="$1"
    local -n _out_vref="$2"
    local -n _out_scale="$3"
    local -n _out_types="$4"
    local -n _out_labels="$5"

    _out_vref=""
    _out_scale=""
    _out_types=()
    _out_labels=()

    if [ ! -f "$template_file" ]; then
        return 1
    fi

    local line=""
    local -a parsed_types=()
    local -a parsed_labels=()
    local read_any=false

    while IFS= read -r line || [ -n "$line" ]; do
        line="${line%%#*}"
        line="${line%$'\r'}"
        line="${line#${line%%[![:space:]]*}}"
        line="${line%${line##*[![:space:]]}}"

        if [ -z "$line" ]; then
            continue
        fi

        read_any=true
        set -- $line

        case "$1" in
            device)
                continue
                ;;
            vref)
                if [ $# -ge 2 ]; then
                    _out_vref="$2"
                fi
                continue
                ;;
            scale)
                if [ $# -ge 2 ]; then
                    _out_scale="$2"
                fi
                continue
                ;;
        esac

        local type="$1"
        shift
        local index=""
        if [ $# -gt 0 ]; then
            index="$1"
            shift
        fi

        if [[ ! "$index" =~ ^[0-9]+$ ]]; then
            continue
        fi

        local label="$type"
        if [ $# -gt 0 ]; then
            label="$*"
        fi

        parsed_types[index]="$type"
        parsed_labels[index]="$label"
    done <"$template_file"

    if [ "$read_any" = false ]; then
        return 1
    fi

    for (( i=0; i<TOTAL_ADC_CHANNELS; i++ )); do
        if [ -n "${parsed_types[i]+set}" ]; then
            _out_types[i]="${parsed_types[i]}"
            if [ -n "${parsed_labels[i]+set}" ] && [ -n "${parsed_labels[i]}" ]; then
                _out_labels[i]="${parsed_labels[i]}"
            else
                _out_labels[i]="${parsed_types[i]}"
            fi
        fi
    done

    return 0
}

# Status, ob "opkg update" bereits erfolgreich ausgeführt wurde
OPKG_UPDATE_PERFORMED=false

# Statusflags für Sicherungen und Wiederherstellungen
configBackupExisted=false
[ -f "$BACKUP_CONFIG_FILE" ] && configBackupExisted=true
configRestorePerformed=false
configTxtRestorePerformed=false
rcLocalBackupAvailable=false
[ -f "$RC_LOCAL_BACKUP" ] && rcLocalBackupAvailable=true
rcLocalRestorePerformed=false

# Kompatibilität prüfen
if [ ! -f /etc/venus/machine ]; then
    logMessage "Kann den Venus-Gerätetyp nicht bestimmen - Skript wird beendet."
    setInstallFailed $EXIT_INCOMPATIBLE_PLATFORM "Kann den Venus-Gerätetyp nicht bestimmen."
fi

machine=$(cat /etc/venus/machine)
if [[ "$machine" != "raspberrypi2" && "$machine" != "raspberrypi4" ]]; then
    logMessage "$machine wird nicht unterstützt - Skript wird beendet."
    setInstallFailed $EXIT_INCOMPATIBLE_PLATFORM "$machine wird nicht unterstützt."
fi

# Funktionen definieren

## Einträge in rc.local hinzufügen und entfernen
# Eintrag in rc.local hinzufügen
add_entry_to_rc_local() {
    local ENTRY="$1"
    local entry_added=0

    if [ ! -f "$RC_LOCAL_FILE" ]; then
        printf '#!/bin/sh\n\n' > "$RC_LOCAL_FILE"
    fi

    if ! grep -qF -- "$ENTRY" "$RC_LOCAL_FILE"; then
        printf '%s\n' "$ENTRY" >> "$RC_LOCAL_FILE"
        entry_added=1
    fi
    chmod +x "$RC_LOCAL_FILE"

    if [ "$entry_added" -eq 1 ]; then
        mkdir -p "$(dirname "$RC_LOCAL_STATE_FILE")"
        if [ ! -f "$RC_LOCAL_STATE_FILE" ]; then
            printf '%s\n' "$ENTRY" > "$RC_LOCAL_STATE_FILE"
        elif ! grep -qFx -- "$ENTRY" "$RC_LOCAL_STATE_FILE"; then
            printf '%s\n' "$ENTRY" >> "$RC_LOCAL_STATE_FILE"
        fi
        logMessage "rc.local Eintrag \"$ENTRY\" wurde hinzugefügt und als durch das Setup verwaltet markiert."
    else
        logMessage "rc.local Eintrag \"$ENTRY\" war bereits vorhanden und bleibt unverändert."
    fi
}

# Eintrag aus rc.local entfernen
remove_entry_from_rc_local() {
    local ENTRY="$1"
    [ -f "$RC_LOCAL_FILE" ] && sed -i "/^$(echo "$ENTRY" | sed 's/[\/&]/\\&/g')$/d" "$RC_LOCAL_FILE"
}

# Hilfsfunktionen zum Verwalten des Overlay-Status
set_overlay_state_value() {
    local state_file="$1"
    local key="$2"
    local value="$3"

    if [ -f "$state_file" ]; then
        if grep -q "^${key}=" "$state_file"; then
            sed -i "s/^${key}=.*/${key}=${value}/" "$state_file"
            return
        fi
    fi

    mkdir -p "$(dirname "$state_file")"
    echo "${key}=${value}" >> "$state_file"
}

get_overlay_state_value() {
    local state_file="$1"
    local key="$2"

    if [ -f "$state_file" ]; then
        grep -E "^${key}=" "$state_file" | tail -n1 | cut -d'=' -f2-
    fi
}

## Originaldateien sichern und wiederherstellen
# Originaldateien sichern
backup_originals() {
    logMessage "Sichere Originaldateien..."
    backupFile "$CONFIG_FILE" "$BACKUP_CONFIG_FILE"
    [ -f "$BACKUP_CONFIG_FILE" ] && configBackupExisted=true
    backupFile "$CONFIG_TXT" "$CONFIG_TXT_BACKUP"
    backupFile "$RC_LOCAL_FILE" "$RC_LOCAL_BACKUP"

    mkdir -p "$OVERLAY_STATE_DIR"
    for overlay in "${OVERLAYS[@]}"; do
        local overlay_path="$OVERLAY_DIR/$overlay"
        local state_file="$OVERLAY_STATE_DIR/${overlay}.state"
        local backup_file="$OVERLAY_STATE_DIR/${overlay}.orig"
        local absent_marker="$OVERLAY_STATE_DIR/${overlay}.absent"
        local timestamp="$(date -u +"%Y-%m-%dT%H:%M:%SZ")"

        local previous_original_state="$(get_overlay_state_value "$state_file" "original")"
        local previous_original_checksum="$(get_overlay_state_value "$state_file" "original_checksum")"
        local previous_original_recorded_at="$(get_overlay_state_value "$state_file" "original_recorded_at")"
        local overlay_previously_absent="false"
        if [ "$previous_original_state" = "absent" ]; then
            overlay_previously_absent="true"
        fi

        local overlay_currently_present="false"
        if [ -f "$overlay_path" ]; then
            overlay_currently_present="true"
        fi

        local retain_existing_backup="false"
        if [ "$previous_original_state" = "present" ] && [ "$overlay_currently_present" = "false" ] && [ -f "$backup_file" ]; then
            retain_existing_backup="true"
        fi

        if [ "$overlay_previously_absent" = "true" ]; then
            if [ "$retain_existing_backup" != "true" ]; then
                rm -f "$backup_file"
            fi
        else
            if [ "$retain_existing_backup" != "true" ]; then
                rm -f "$backup_file"
            fi
            rm -f "$absent_marker"
        fi
        : > "$state_file"

        if [ "$overlay_previously_absent" = "true" ]; then
            if [ ! -f "$absent_marker" ]; then
                : > "$absent_marker"
            fi

            logMessage "Overlay $overlay war zuvor als 'absent' markiert. Historie wird beibehalten."
            set_overlay_state_value "$state_file" "original" "absent"
            if [ -n "$previous_original_checksum" ]; then
                set_overlay_state_value "$state_file" "original_checksum" "$previous_original_checksum"
            else
                set_overlay_state_value "$state_file" "original_checksum" "nicht_vorhanden"
            fi
            if [ -n "$previous_original_recorded_at" ]; then
                set_overlay_state_value "$state_file" "original_recorded_at" "$previous_original_recorded_at"
            else
                set_overlay_state_value "$state_file" "original_recorded_at" "$timestamp"
            fi
            set_overlay_state_value "$state_file" "installed_by_setup" "true"
            set_overlay_state_value "$state_file" "last_action" "absent_preserved"
            continue
        fi

        if [ "$retain_existing_backup" = "true" ]; then
            logMessage "Overlay $overlay fehlt aktuell; vorhandenes Backup wird beibehalten."
            set_overlay_state_value "$state_file" "original" "present"
            if [ -n "$previous_original_checksum" ]; then
                set_overlay_state_value "$state_file" "original_checksum" "$previous_original_checksum"
            else
                set_overlay_state_value "$state_file" "original_checksum" "unbekannt"
            fi
            if [ -n "$previous_original_recorded_at" ]; then
                set_overlay_state_value "$state_file" "original_recorded_at" "$previous_original_recorded_at"
            else
                set_overlay_state_value "$state_file" "original_recorded_at" "$timestamp"
            fi
            set_overlay_state_value "$state_file" "installed_by_setup" "false"
            set_overlay_state_value "$state_file" "last_action" "backup_retained_missing_overlay"
            continue
        fi

        if [ "$overlay_currently_present" = "true" ]; then
            if cp "$overlay_path" "$backup_file"; then
                local checksum="unbekannt"
                if command -v sha256sum >/dev/null 2>&1; then
                    checksum="$(sha256sum "$overlay_path" | awk '{print $1}')"
                fi
                logMessage "Overlay $overlay wurde gesichert (Checksumme: $checksum)."
                set_overlay_state_value "$state_file" "original" "present"
                set_overlay_state_value "$state_file" "original_checksum" "$checksum"
                set_overlay_state_value "$state_file" "original_recorded_at" "$timestamp"
                set_overlay_state_value "$state_file" "installed_by_setup" "false"
                set_overlay_state_value "$state_file" "last_action" "backup_recorded"
            else
                logMessage "Fehler beim Sichern von Overlay $overlay."
                setInstallFailed $EXIT_ERROR "Fehler beim Sichern von Overlay $overlay."
            fi
        else
            logMessage "Overlay $overlay war vor der Installation nicht vorhanden. Markiere Zustand als 'absent'."
            : > "$absent_marker"
            set_overlay_state_value "$state_file" "original" "absent"
            set_overlay_state_value "$state_file" "original_checksum" "nicht_vorhanden"
            set_overlay_state_value "$state_file" "original_recorded_at" "$timestamp"
            set_overlay_state_value "$state_file" "installed_by_setup" "false"
            set_overlay_state_value "$state_file" "last_action" "original_absent_recorded"
        fi
    done
}

# Originaldateien wiederherstellen
restore_originals() {
    logMessage "Stelle Originaldateien wieder her..."
    if restoreFile "$BACKUP_CONFIG_FILE" "$CONFIG_FILE"; then
        configRestorePerformed=true
        logMessage "Originale dbus-adc.conf wurde erfolgreich wiederhergestellt."
    else
        configRestorePerformed=false
        if [ -f "$BACKUP_CONFIG_FILE" ]; then
            logMessage "Warnung: Wiederherstellung der dbus-adc.conf aus der Sicherung ist fehlgeschlagen."
        else
            logMessage "Keine Sicherung der dbus-adc.conf gefunden; Setup-Version bleibt bestehen."
        fi
    fi

    if [ -f "$BACKUP_CONFIG_FILE" ]; then
        configBackupExisted=true
    else
        configBackupExisted=false
    fi

    if restoreFile "$CONFIG_TXT_BACKUP" "$CONFIG_TXT"; then
        configTxtRestorePerformed=true
        logMessage "config.txt wurde erfolgreich aus der Sicherung wiederhergestellt."
    else
        configTxtRestorePerformed=false
        if [ -f "$CONFIG_TXT_BACKUP" ]; then
            logMessage "Warnung: Wiederherstellung der config.txt aus der Sicherung ist fehlgeschlagen."
        else
            logMessage "Keine Sicherung der config.txt gefunden; setze auf manuelle Bereinigung."
        fi
    fi
    if [ -f "$RC_LOCAL_BACKUP" ]; then
        rcLocalBackupAvailable=true
    else
        rcLocalBackupAvailable=false
    fi

    if restoreFile "$RC_LOCAL_BACKUP" "$RC_LOCAL_FILE"; then
        rcLocalRestorePerformed=true
        logMessage "rc.local wurde erfolgreich aus der Sicherung wiederhergestellt."
    else
        rcLocalRestorePerformed=false
        if [ "$rcLocalBackupAvailable" = true ]; then
            logMessage "Warnung: Wiederherstellung der rc.local aus der Sicherung ist fehlgeschlagen."
        else
            logMessage "Keine Sicherung der rc.local gefunden; setze auf gezielte Bereinigung."
        fi
    fi
}

## Hilfsfunktionen für Benutzereingaben
normalize_channel_label() {
    local input="$1"
    local fallback="$2"

    local trimmed
    trimmed="$(printf '%s' "$input" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')"

    if [ -z "$trimmed" ]; then
        trimmed="$fallback"
    fi

    local lowered
    lowered="$(printf '%s' "$trimmed" | tr '[:upper:]' '[:lower:]')"

    if [[ "$lowered" =~ ^[[:alnum:]][[:alnum:]_.:/-]*$ ]]; then
        printf '%s' "$lowered"
        return 0
    fi

    local sanitized
    sanitized="$(printf '%s' "$lowered" | tr -cd '[:alnum:]_.:/-')"

    if [ -z "$sanitized" ]; then
        sanitized="$fallback"
    fi

    sanitized="$(printf '%s' "$sanitized" | tr '[:upper:]' '[:lower:]')"

    if [[ "$sanitized" =~ ^[[:alnum:]][[:alnum:]_.:/-]*$ ]]; then
        printf '%s' "$sanitized"
    else
        printf '%s' "$(printf '%s' "$fallback" | tr '[:upper:]' '[:lower:]')"
    fi
}

is_truthy() {
    local value="$1"
    case "${value,,}" in
        1|true|yes|y|on)
            return 0
            ;;
    esac
    return 1
}

## Benutzerinteraktion für die dbus-adc Konfiguration
prompt_numeric_value() {
    local prompt_text="$1"
    local default_value="$2"
    local validation_regex="$3"
    local error_message="$4"
    local env_var_name="${5:-}"
    local value=""

    if [ "$nonInteractiveMode" = true ]; then
        local candidate="$default_value"
        local source="Standardwert"
        if [ -n "$env_var_name" ]; then
            local env_value="${!env_var_name:-}"
            if [ -n "$env_value" ]; then
                candidate="$env_value"
                source="Umgebungsvariable ${env_var_name}"
            fi
        fi

        if [[ "$candidate" =~ $validation_regex ]]; then
            logMessage "Nicht-interaktiv: verwende ${source} (${candidate}) für ${prompt_text}."
            echo "$candidate"
            return 0
        fi

        logMessage "Nicht-interaktiv: ${source} '${candidate}' ist ungültig für ${prompt_text}. Verwende Fallback '${default_value}'."

        if [ -n "$default_value" ] && [[ "$default_value" =~ $validation_regex ]]; then
            echo "$default_value"
            return 0
        fi

        local fallback_candidate=""
        case "$env_var_name" in
            EXPANDERPI_VREF)
                fallback_candidate="$DEFAULT_VREF_FALLBACK"
                ;;
            EXPANDERPI_SCALE)
                fallback_candidate="$DEFAULT_SCALE_FALLBACK"
                ;;
        esac

        if [ -n "$fallback_candidate" ] && [[ "$fallback_candidate" =~ $validation_regex ]]; then
            logMessage "Nicht-interaktiv: setze ${prompt_text} auf Skriptstandard ${fallback_candidate}."
            echo "$fallback_candidate"
            return 0
        fi

        logMessage "Nicht-interaktiv: Konnte keinen gültigen Wert für ${prompt_text} bestimmen. Setze auf '0'."
        echo "0"
        return 0
    fi

    while true; do
        if [ -n "$default_value" ]; then
            read -rp "${prompt_text} [${default_value}]: " value
        else
            read -rp "${prompt_text}: " value
        fi

        if [ -z "$value" ]; then
            value="$default_value"
        fi

        if [ -z "$value" ]; then
            logMessage "$error_message"
            continue
        fi

        if [[ "$value" =~ $validation_regex ]]; then
            if declare -F yesNoPrompt >/dev/null 2>&1; then
                if yesNoPrompt "Wert '${value}' übernehmen (y/n)? "; then
                    echo "$value"
                    return 0
                else
                    logMessage "Eingabe verworfen. Bitte erneut eingeben."
                    continue
                fi
            else
                echo "$value"
                return 0
            fi
        fi

        logMessage "$error_message"
    done
}

prompt_sensor_label() {
    local channel="$1"
    local default_value="$2"
    local require_non_empty="${3:-false}"
    local prompt_text="Sensorbezeichnung für Kanal ${channel}"
    local input=""

    if [ "$nonInteractiveMode" = true ]; then
        local env_var_name="EXPANDERPI_CHANNEL_${channel}_LABEL"
        local candidate="${!env_var_name:-$default_value}"
        local fallback="sensor_${channel}"

        if [ "$require_non_empty" = false ] && [ -z "$candidate" ]; then
            logMessage "Nicht-interaktiv: Kanal ${channel} bleibt ohne Sensor."
            echo ""
            return 0
        fi

        if [ -z "$candidate" ]; then
            candidate="$fallback"
            logMessage "Nicht-interaktiv: verwende Platzhalter '${candidate}' für Kanal ${channel}."
        else
            logMessage "Nicht-interaktiv: verwende Umgebungswert '${candidate}' für Kanal ${channel}."
        fi

        local normalized
        normalized="$(normalize_channel_label "$candidate" "$fallback")"
        echo "$normalized"
        return 0
    fi

    while true; do
        if [ -n "$default_value" ]; then
            read -rp "${prompt_text} (${default_value}): " input
        else
            read -rp "${prompt_text}: " input
        fi

        if [ -z "$input" ]; then
            input="$default_value"
        fi

        local trimmed_input
        trimmed_input="$(printf '%s' "$input" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')"
        local lowered_input
        lowered_input="$(printf '%s' "$trimmed_input" | tr '[:upper:]' '[:lower:]')"

        if [ -z "$trimmed_input" ] || [[ "$lowered_input" =~ ^(-|none|leer|kein|keine|aus)$ ]]; then
            if [ "$require_non_empty" = "true" ]; then
                logMessage "Bitte eine Sensorbezeichnung für Kanal ${channel} angeben."
                continue
            fi

            if declare -F yesNoPrompt >/dev/null 2>&1; then
                if yesNoPrompt "Kanal ${channel} ohne Sensor belassen (y/n)? "; then
                    echo ""
                    return 0
                else
                    logMessage "Bitte Sensorbezeichnung erneut angeben."
                    continue
                fi
            else
                echo ""
                return 0
            fi
        fi

        if [[ "$trimmed_input" =~ ^[[:alnum:]][[:alnum:]_.:/-]*$ ]]; then
            local normalized_input
            normalized_input="$(printf '%s' "$trimmed_input" | tr '[:upper:]' '[:lower:]')"

            if declare -F yesNoPrompt >/dev/null 2>&1; then
                if yesNoPrompt "Sensor '${normalized_input}' für Kanal ${channel} übernehmen (y/n)? "; then
                    echo "$normalized_input"
                    return 0
                else
                    logMessage "Eingabe verworfen. Bitte erneut angeben."
                    continue
                fi
            else
                echo "$normalized_input"
                return 0
            fi
        fi

        logMessage "Ungültige Eingabe für Kanal ${channel}. Bitte nur Buchstaben, Zahlen sowie '._:/-' verwenden."
    done
}

prompt_channel_assignment() {
    local channel="$1"
    local default_type="$2"
    local default_label="$3"

    if [ "$nonInteractiveMode" = true ]; then
        local env_var_base="EXPANDERPI_CHANNEL_${channel}"
        local env_value="${!env_var_base:-}"
        local env_type_var="${env_var_base}_TYPE"
        local env_label_var="${env_var_base}_LABEL"
        local env_type="${!env_type_var:-}"
        local env_label="${!env_label_var:-}"

        local raw_type=""
        local raw_label=""

        if [ -n "$env_value" ]; then
            local IFS='|:;, '
            read -r raw_type raw_label <<< "$env_value"
        fi

        if [ -z "$raw_type" ] && [ -n "$env_type" ]; then
            raw_type="$env_type"
        fi

        if [ -z "$raw_label" ] && [ -n "$env_label" ]; then
            raw_label="$env_label"
        fi

        if [ -z "$raw_type" ]; then
            raw_type="$default_type"
        fi

        local normalized_type
        local normalized_label="${raw_label}"
        local log_source="automatisch"

        if [ -n "$env_value" ] || [ -n "$env_type" ]; then
            log_source="Umgebungsvariablen"
        elif [ -n "$default_type" ]; then
            log_source="Standardwerte"
        fi

        case "${raw_type,,}" in
            ""|none|leer|aus|kein|keine|0)
                normalized_type="none"
                normalized_label=""
                logMessage "Nicht-interaktiv: ${log_source} führen dazu, dass Kanal ${channel} leer bleibt."
                printf 'none|\n'
                return 0
                ;;
            tank|t|tank-sensor|tanksensor)
                normalized_type="tank"
                local tank_fallback="tank"
                if [ -z "$normalized_label" ]; then
                    if [ -n "$default_label" ]; then
                        normalized_label="$default_label"
                    else
                        normalized_label="$tank_fallback"
                    fi
                fi
                normalized_label="$(normalize_channel_label "$normalized_label" "$tank_fallback")"
                logMessage "Nicht-interaktiv: Kanal ${channel} als Tank-Sensor (${normalized_label})."
                printf 'tank|%s\n' "$normalized_label"
                return 0
                ;;
            temp|temperatur|temperature|tempsensor|temp-sensor)
                normalized_type="temp"
                local temp_fallback="temp"
                if [ -z "$normalized_label" ]; then
                    if [ -n "$default_label" ]; then
                        normalized_label="$default_label"
                    else
                        normalized_label="$temp_fallback"
                    fi
                fi
                normalized_label="$(normalize_channel_label "$normalized_label" "$temp_fallback")"
                logMessage "Nicht-interaktiv: Kanal ${channel} als Temperatur-Sensor (${normalized_label})."
                printf 'temp|%s\n' "$normalized_label"
                return 0
                ;;
            custom|benutzerdefiniert|user|label|sensor)
                normalized_type="custom"
                local custom_fallback="sensor_${channel}"
                if [ -z "$normalized_label" ]; then
                    if [ -n "$default_label" ]; then
                        normalized_label="$default_label"
                    else
                        normalized_label="$custom_fallback"
                    fi
                fi
                normalized_label="$(normalize_channel_label "$normalized_label" "$custom_fallback")"
                logMessage "Nicht-interaktiv: Kanal ${channel} als benutzerdefiniert (${normalized_label})."
                printf 'custom|%s\n' "$normalized_label"
                return 0
                ;;
            *)
                normalized_type="custom"
                local generic_fallback="sensor_${channel}"
                if [ -z "$normalized_label" ]; then
                    normalized_label="$raw_type"
                fi
                normalized_label="$(normalize_channel_label "$normalized_label" "$generic_fallback")"
                logMessage "Nicht-interaktiv: Kanal ${channel} als benutzerdefiniert (${normalized_label})."
                printf 'custom|%s\n' "$normalized_label"
                return 0
                ;;
        esac
    fi

    local normalized_default_type
    case "$default_type" in
        ""|"none")
            normalized_default_type="none"
            ;;
        tank|temp|custom|none)
            normalized_default_type="$default_type"
            ;;
        *)
            normalized_default_type="custom"
            ;;
    esac

    local prompt_suffix=""
    case "$normalized_default_type" in
        tank)
            prompt_suffix="tank"
            ;;
        temp)
            prompt_suffix="temp"
            ;;
        custom)
            if [ -n "$default_label" ]; then
                prompt_suffix="benutzerdefiniert (${default_label})"
            else
                prompt_suffix="benutzerdefiniert"
            fi
            ;;
        none)
            prompt_suffix="leer"
            ;;
    esac

    while true; do
        local reply=""
        if [ -n "$prompt_suffix" ]; then
            read -rp "Sensortyp für Kanal ${channel} [${prompt_suffix}]: " reply
        else
            read -rp "Sensortyp für Kanal ${channel}: " reply
        fi

        if [ -z "$reply" ]; then
            reply="$normalized_default_type"
        fi

        reply="$(printf '%s' "$reply" | tr '[:upper:]' '[:lower:]')"

        case "$reply" in
            ""|"none"|"leer"|"aus"|"kein"|"keine"|"0")
                if declare -F yesNoPrompt >/dev/null 2>&1; then
                    if yesNoPrompt "Kanal ${channel} ohne Sensor übernehmen (y/n)? "; then
                        printf 'none|\n'
                        return 0
                    else
                        logMessage "Bitte Auswahl erneut treffen."
                        continue
                    fi
                else
                    printf 'none|\n'
                    return 0
                fi
                ;;
            tank|t|tank-sensor|tanksensor)
                if declare -F yesNoPrompt >/dev/null 2>&1; then
                    if ! yesNoPrompt "Kanal ${channel} als Tank-Sensor übernehmen (y/n)? "; then
                        logMessage "Bitte Auswahl erneut treffen."
                        continue
                    fi
                fi
                local tank_label="$default_label"
                if [ -z "$tank_label" ]; then
                    tank_label="tank"
                fi
                printf 'tank|%s\n' "$tank_label"
                return 0
                ;;
            temp|temperatur|temperature|tempsensor|temp-sensor)
                if declare -F yesNoPrompt >/dev/null 2>&1; then
                    if ! yesNoPrompt "Kanal ${channel} als Temperatur-Sensor übernehmen (y/n)? "; then
                        logMessage "Bitte Auswahl erneut treffen."
                        continue
                    fi
                fi
                local temp_label="$default_label"
                if [ -z "$temp_label" ]; then
                    temp_label="temp"
                fi
                printf 'temp|%s\n' "$temp_label"
                return 0
                ;;
            custom|benutzerdefiniert|user|label|sensor)
                local custom_label
                custom_label="$(prompt_sensor_label "$channel" "$default_label" true)"
                if [ -z "$custom_label" ]; then
                    logMessage "Benutzerdefinierte Sensorbezeichnung darf nicht leer sein."
                    continue
                fi
                printf 'custom|%s\n' "$custom_label"
                return 0
                ;;
            *)
                if [[ "$reply" =~ ^[[:alnum:]][[:alnum:]_.:/-]*$ ]]; then
                    if declare -F yesNoPrompt >/dev/null 2>&1; then
                        if ! yesNoPrompt "Kanal ${channel} als '${reply}' übernehmen (y/n)? "; then
                            logMessage "Bitte Auswahl erneut treffen."
                            continue
                        fi
                    fi
                    printf 'custom|%s\n' "$reply"
                    return 0
                fi

                logMessage "Ungültige Auswahl für Kanal ${channel}. Gültig sind 'tank', 'temp', 'custom' oder eine eigene Bezeichnung."
                ;;
        esac
    done
}

## Konfigurationsdateien installieren und deinstallieren
# Konfigurationsdateien installieren
install_config() {
    logMessage "Installiere dbus-adc.conf..."
    mkdir -p "$ROOT_PATH"

    local template_file="${SOURCE_FILE_DIR}/configs/dbus-adc.conf"
    local default_vref=""
    local default_scale=""
    local -a default_channel_types=()
    local -a default_channel_labels=()
    local template_loaded=false
    local -a fallback_messages=()

    if parse_default_adc_configuration "$template_file" default_vref default_scale default_channel_types default_channel_labels; then
        template_loaded=true
    else
        logMessage "Konfigurationsvorlage '${template_file}' konnte nicht geladen werden. Verwende Fallback-Werte."
    fi

    if [ -z "$default_vref" ]; then
        default_vref="$DEFAULT_VREF_FALLBACK"
        fallback_messages+=("Vref (${DEFAULT_VREF_FALLBACK})")
    fi

    if [ -z "$default_scale" ]; then
        default_scale="$DEFAULT_SCALE_FALLBACK"
        fallback_messages+=("Scale (${DEFAULT_SCALE_FALLBACK})")
    fi

    local channels_fallback=false
    for (( channel=0; channel<TOTAL_ADC_CHANNELS; channel++ )); do
        if [ -z "${default_channel_types[channel]+set}" ] || [ -z "${default_channel_types[channel]}" ]; then
            if [ -n "${DEFAULT_CHANNEL_TYPES_FALLBACK[channel]+set}" ]; then
                default_channel_types[channel]="${DEFAULT_CHANNEL_TYPES_FALLBACK[channel]}"
            else
                default_channel_types[channel]=""
            fi
            channels_fallback=true
        fi

        if [ -z "${default_channel_labels[channel]+set}" ] || [ -z "${default_channel_labels[channel]}" ]; then
            if [ -n "${default_channel_types[channel]}" ]; then
                default_channel_labels[channel]="${default_channel_types[channel]}"
            elif [ -n "${DEFAULT_CHANNEL_LABELS_FALLBACK[channel]+set}" ]; then
                default_channel_labels[channel]="${DEFAULT_CHANNEL_LABELS_FALLBACK[channel]}"
            else
                default_channel_labels[channel]=""
            fi
            channels_fallback=true
        fi
    done

    if [ "$channels_fallback" = true ]; then
        fallback_messages+=("Kanäle (Fallback-Vorbelegung)")
    fi

    if [ "${#fallback_messages[@]}" -gt 0 ] && [ "$template_loaded" = true ]; then
        logMessage "Unvollständige Angaben in '${template_file}'. Fallback-Werte verwendet für: ${fallback_messages[*]}."
    elif [ "${#fallback_messages[@]}" -gt 0 ]; then
        logMessage "Fallback-Werte verwendet für: ${fallback_messages[*]}."
    fi

    local -a channel_types
    local -a channel_labels
    local -a saved_channel_types
    local -a saved_channel_labels
    local channel

    for (( channel=0; channel<TOTAL_ADC_CHANNELS; channel++ )); do
        channel_types[channel]="${default_channel_types[channel]}"
        channel_labels[channel]="${default_channel_labels[channel]}"
        saved_channel_types[channel]=""
        saved_channel_labels[channel]=""
    done

    local saved_vref=""
    local saved_scale=""
    if [ -f "$USER_CONFIG_FILE" ]; then
        # shellcheck source=/dev/null
        source "$USER_CONFIG_FILE"
        saved_vref="${USER_VREF:-}"
        saved_scale="${USER_SCALE:-}"
        for (( channel=0; channel<TOTAL_ADC_CHANNELS; channel++ )); do
            local label_var="USER_CHANNEL_${channel}"
            local type_var="USER_CHANNEL_${channel}_TYPE"
            local saved_label=""
            local saved_type=""

            if eval "[[ -v ${label_var} ]]" 2>/dev/null; then
                saved_label="$(eval "printf '%s' \"\${$label_var}\"")"
            fi

            if eval "[[ -v ${type_var} ]]" 2>/dev/null; then
                saved_type="$(eval "printf '%s' \"\${$type_var}\"")"
            fi

            if [ -z "$saved_type" ]; then
                case "$saved_label" in
                    tank)
                        saved_type="tank"
                        ;;
                    temp)
                        saved_type="temp"
                        ;;
                    "")
                        saved_type="none"
                        ;;
                    *)
                        saved_type="custom"
                        ;;
                esac
            fi

            saved_channel_labels[channel]="$saved_label"
            saved_channel_types[channel]="$saved_type"
        done
    fi

    if load_gui_configuration; then
        logMessage "Übernehme Werte aus der SetupHelper-Oberfläche für die nicht-interaktive Ausführung."
        nonInteractiveMode=true
        if [ -n "${EXPANDERPI_VREF:-}" ]; then
            saved_vref="${EXPANDERPI_VREF}";
        fi
        if [ -n "${EXPANDERPI_SCALE:-}" ]; then
            saved_scale="${EXPANDERPI_SCALE}";
        fi

        for (( channel=0; channel<TOTAL_ADC_CHANNELS; channel++ )); do
            local gui_type_var="EXPANDERPI_CHANNEL_${channel}_TYPE"
            local gui_label_var="EXPANDERPI_CHANNEL_${channel}_LABEL"
            local gui_type="${!gui_type_var:-}"
            local gui_label="${!gui_label_var:-}"

            if [ -n "$gui_type" ]; then
                saved_channel_types[channel]="$gui_type"
            fi

            if [ -n "$gui_label" ]; then
                saved_channel_labels[channel]="$gui_label"
            fi
        done
    fi

    local use_saved=false
    if [ -n "$saved_vref" ] || [ -n "$saved_scale" ]; then
        local summary=""
        for (( channel=0; channel<TOTAL_ADC_CHANNELS; channel++ )); do
            local type_value="${saved_channel_types[channel]}"
            local label_value="${saved_channel_labels[channel]}"
            if [ -n "$label_value" ]; then
                summary+="Kanal ${channel}: ${label_value} (${type_value}), "
            else
                summary+="Kanal ${channel}: leer, "
            fi
        done
        summary="${summary%, }"

        logMessage "Gefundene gespeicherte Werte: Vref=${saved_vref:-nicht gesetzt}, Scale=${saved_scale:-nicht gesetzt}."
        logMessage "Gespeicherte Kanalzuordnung: ${summary}"
        if [ "$nonInteractiveMode" = true ]; then
            local use_saved_env="${EXPANDERPI_USE_SAVED:-}"
            if [ -n "$use_saved_env" ]; then
                if is_truthy "$use_saved_env"; then
                    use_saved=true
                    logMessage "Nicht-interaktiv: verwende gespeicherte Konfiguration gemäß EXPANDERPI_USE_SAVED=${use_saved_env}."
                else
                    use_saved=false
                    logMessage "Nicht-interaktiv: verwerfe gespeicherte Konfiguration gemäß EXPANDERPI_USE_SAVED=${use_saved_env}."
                fi
            else
                use_saved=true
                logMessage "Nicht-interaktiv: verwende automatisch die gespeicherten Werte."
            fi
        else
            if declare -F yesNoPrompt >/dev/null 2>&1; then
                if yesNoPrompt "Gespeicherte Konfiguration wiederverwenden (y/n)? "; then
                    use_saved=true
                fi
            else
                local response=""
                while true; do
                    read -rp "Gespeicherte Konfiguration wiederverwenden (y/n)? " response
                    case "$response" in
                        [yY]*)
                            use_saved=true
                            break
                            ;;
                        [nN]*)
                            use_saved=false
                            break
                            ;;
                    esac
                done
            fi
        fi
    fi

    local vref_value=""
    local scale_value=""

    if $use_saved; then
        vref_value="${saved_vref:-$default_vref}"
        scale_value="${saved_scale:-$default_scale}"
        for (( channel=0; channel<TOTAL_ADC_CHANNELS; channel++ )); do
            local saved_label="${saved_channel_labels[channel]}"
            local saved_type="${saved_channel_types[channel]}"
            channel_types[channel]="$saved_type"

            if [ -n "$saved_label" ] && [ "$saved_type" != "none" ]; then
                channel_labels[channel]="$saved_label"
            else
                channel_labels[channel]=""
            fi
        done
        logMessage "Gespeicherte Konfiguration wird erneut angewendet."
    else
        local prompt_vref_default="${saved_vref:-$default_vref}"
        local prompt_scale_default="${saved_scale:-$default_scale}"
        vref_value="$(prompt_numeric_value "Referenzspannung (Vref)" "$prompt_vref_default" '^[0-9]+([.][0-9]+)?$' "Bitte eine gültige Zahl für Vref eingeben." "EXPANDERPI_VREF")"
        scale_value="$(prompt_numeric_value "Skalierungsfaktor (Scale)" "$prompt_scale_default" '^[0-9]+$' "Bitte eine ganze Zahl für den Skalierungsfaktor angeben." "EXPANDERPI_SCALE")"

        for (( channel=0; channel<TOTAL_ADC_CHANNELS; channel++ )); do
            local default_type="${saved_channel_types[channel]}"
            local default_label="${saved_channel_labels[channel]}"

            if [ -z "$default_type" ]; then
                default_type="${channel_types[channel]}"
            fi

            if [ "$default_type" = "none" ]; then
                default_label=""
            elif [ -z "$default_label" ]; then
                default_label="${channel_labels[channel]}"
            fi

            local response
            response="$(prompt_channel_assignment "$channel" "$default_type" "$default_label")"
            local selected_type="${response%%|*}"
            local selected_label="${response#*|}"

            channel_types[channel]="${selected_type:-none}"
            channel_labels[channel]="$selected_label"
        done
    fi

    local mapping_summary=""
    for (( channel=0; channel<TOTAL_ADC_CHANNELS; channel++ )); do
        if [ -n "${channel_labels[channel]}" ]; then
            mapping_summary+="Kanal ${channel}: ${channel_labels[channel]} (${channel_types[channel]}), "
        else
            mapping_summary+="Kanal ${channel}: leer, "
        fi
    done
    mapping_summary="${mapping_summary%, }"

    logMessage "Verwende Vref=${vref_value}, Scale=${scale_value}."
    logMessage "Kanalzuordnung: ${mapping_summary}"

    local temp_config
    if ! temp_config="$(mktemp)"; then
        logMessage "Fehler: Konnte temporäre Datei für dbus-adc.conf nicht erstellen."
        setInstallFailed $EXIT_ERROR "mktemp für dbus-adc.conf fehlgeschlagen."
        return
    fi

    {
        echo "$ADC_DEVICE_LINE"
        echo "vref ${vref_value}"
        echo "scale ${scale_value}"
        echo
        for (( channel=0; channel<TOTAL_ADC_CHANNELS; channel++ )); do
            if [ -n "${channel_labels[channel]}" ]; then
                echo "${channel_labels[channel]} ${channel}"
            fi
        done
    } > "$temp_config"

    local config_changed=true
    local dbus_config_copied=false
    if [ -f "$CONFIG_FILE" ] && cmp -s "$temp_config" "$CONFIG_FILE"; then
        config_changed=false
        logMessage "dbus-adc.conf ist bereits aktuell; keine Änderungen erforderlich."
    else
        if cp "$temp_config" "$CONFIG_FILE"; then
            logMessage "dbus-adc.conf mit den neuen Werten geschrieben."
            filesUpdated=true
            dbus_config_copied=true
        else
            logMessage "Fehler beim Schreiben der dbus-adc.conf."
            setInstallFailed $EXIT_ERROR "Fehler beim Schreiben der dbus-adc.conf."
        fi
    fi

    rm -f "$temp_config"

    {
        echo "USER_VREF=\"${vref_value}\""
        echo "USER_SCALE=\"${scale_value}\""
        for (( channel=0; channel<TOTAL_ADC_CHANNELS; channel++ )); do
            local value="${channel_labels[channel]}"
            local type_value="${channel_types[channel]}"
            echo "USER_CHANNEL_${channel}=\"${value}\""
            echo "USER_CHANNEL_${channel}_TYPE=\"${type_value}\""
            echo "USER_CHANNEL_${channel}_LABEL=\"${value}\""
        done
    } > "$USER_CONFIG_FILE"

    logMessage "Benutzerkonfiguration unter ${USER_CONFIG_FILE} gespeichert."

    if ! $config_changed; then
        logMessage "Bestehende Konfiguration musste nicht überschrieben werden."
    fi

    logMessage "Aktualisiere $CONFIG_TXT..."
    local config_txt_changed=false
    if ! grep -q "dtoverlay=i2c-rtc,ds1307-rtc" "$CONFIG_TXT"; then
        echo "dtoverlay=i2c-rtc,ds1307-rtc" >> "$CONFIG_TXT"
        filesUpdated=true
        config_txt_changed=true
        logMessage "dtoverlay=i2c-rtc,ds1307-rtc zu $CONFIG_TXT hinzugefügt."
    fi
    if ! grep -q "dtoverlay=mcp3208:spi0-0-present" "$CONFIG_TXT"; then
        echo "dtoverlay=mcp3208:spi0-0-present" >> "$CONFIG_TXT"
        filesUpdated=true
        config_txt_changed=true
        logMessage "dtoverlay=mcp3208:spi0-0-present zu $CONFIG_TXT hinzugefügt."
    fi

    if [ "$config_txt_changed" = true ]; then
        logMessage "$CONFIG_TXT aktualisiert."
    else
        logMessage "$CONFIG_TXT unverändert."
    fi

    if [ "$config_changed" = true ] || [ "$config_txt_changed" = true ]; then
        rebootNeeded=true
        local restart_reason="Konfigurationsdateien geändert"
        if [ "$config_changed" = true ] && [ "$config_txt_changed" != true ]; then
            restart_reason="dbus-adc.conf geändert"
        elif [ "$config_changed" != true ] && [ "$config_txt_changed" = true ]; then
            restart_reason="$CONFIG_TXT geändert"
        elif [ "$config_changed" = true ] && [ "$config_txt_changed" = true ]; then
            restart_reason="dbus-adc.conf und $CONFIG_TXT geändert"
        fi
        logMessage "Neustartbedarf gesetzt, da ${restart_reason}."
    else
        logMessage "Neustart nicht erforderlich: dbus-adc.conf und $CONFIG_TXT blieben unverändert."
    fi
}

# Konfigurationsdateien deinstallieren
uninstall_config() {
    logMessage "Entferne Konfigurationsdateien..."
    if [ "$configTxtRestorePerformed" = true ]; then
        logMessage "config.txt stammt aus der Sicherung; manuelle Bereinigung nicht erforderlich."
    else
        logMessage "Bereinige config.txt manuell, da keine Sicherung wiederhergestellt werden konnte."
        sed -i '/dtoverlay=i2c-rtc,ds1307-rtc/d' "$CONFIG_TXT"
        sed -i '/dtoverlay=mcp3208:spi0-0-present/d' "$CONFIG_TXT"
        logMessage "dtoverlay-Einträge wurden manuell aus der config.txt entfernt."
    fi

    remove_entry_from_rc_local "echo ds1307 0x68 > /sys/class/i2c-adapter/i2c-1/new_device"
    remove_entry_from_rc_local "hwclock -s"

    local backup_file_present=false
    [ -f "$BACKUP_CONFIG_FILE" ] && backup_file_present=true

    if [ "$configRestorePerformed" = true ]; then
        if [ -f "$CONFIG_FILE" ]; then
            logMessage "Originale dbus-adc.conf wurde wiederhergestellt und bleibt erhalten."
        else
            logMessage "Warnung: Wiederhergestellte dbus-adc.conf wurde nicht gefunden."
        fi

        if [ "$backup_file_present" = true ]; then
            logMessage "Sicherungsdatei dbus-adc.conf.orig ist weiterhin vorhanden."
        else
            logMessage "Sicherungsdatei dbus-adc.conf.orig wurde bereits entfernt."
        fi
    else
        if [ "$backup_file_present" = true ]; then
            logMessage "Sicherungsdatei dbus-adc.conf.orig ist vorhanden, konnte jedoch nicht wiederhergestellt werden."
        else
            logMessage "Keine Sicherung der dbus-adc.conf verfügbar; entferne Setup-Version."
        fi

        if [ -f "$CONFIG_FILE" ]; then
            if rm -f "$CONFIG_FILE"; then
                logMessage "dbus-adc.conf aus dem Setup wurde entfernt."
            else
                logMessage "Fehler beim Entfernen der dbus-adc.conf."
                setInstallFailed $EXIT_ERROR "Fehler beim Entfernen der dbus-adc.conf."
            fi
        else
            logMessage "dbus-adc.conf war nicht vorhanden und musste nicht entfernt werden."
        fi
    fi

    logMessage "Konfigurationsdateien deinstalliert."
}

## Overlays prüfen und wiederherstellen bzw. entfernen
# Overlays prüfen und wiederherstellen
check_and_restore_overlays() {
    logMessage "Prüfe und stelle Overlays wieder her..."
    for overlay in "${OVERLAYS[@]}"; do
        local state_file="$OVERLAY_STATE_DIR/${overlay}.state"
        if [ ! -f "$OVERLAY_DIR/$overlay" ]; then
            logMessage "Overlay $overlay fehlt. Wiederherstellung aus $SOURCE_FILE_DIR/overlays..."
            if [ -f "$SOURCE_FILE_DIR/overlays/$overlay" ]; then
                if cp "$SOURCE_FILE_DIR/overlays/$overlay" "$OVERLAY_DIR/"; then
                    logMessage "Overlay $overlay erfolgreich wiederhergestellt."
                    set_overlay_state_value "$state_file" "installed_by_setup" "true"
                    rebootNeeded=true
                else
                    logMessage "Fehler beim Wiederherstellen von Overlay $overlay."
                    setInstallFailed $EXIT_ERROR "Fehler beim Wiederherstellen von Overlay $overlay."
                fi
            else
                logMessage "Fehler: Quelle für Overlay $overlay nicht gefunden."
                setInstallFailed $EXIT_FILE_SET_ERROR "Fehler: Quelle für Overlay $overlay nicht gefunden."
            fi
        else
            logMessage "Overlay $overlay ist bereits vorhanden."
        fi
    done
}

# Overlays entfernen
remove_overlays() {
    logMessage "Entferne oder stelle Overlays wieder her..."
    for overlay in "${OVERLAYS[@]}"; do
        local overlay_path="$OVERLAY_DIR/$overlay"
        local state_file="$OVERLAY_STATE_DIR/${overlay}.state"
        local backup_file="$OVERLAY_STATE_DIR/${overlay}.orig"
        local absent_marker="$OVERLAY_STATE_DIR/${overlay}.absent"
        local original_state="$(get_overlay_state_value "$state_file" "original")"
        local installed_by_setup="$(get_overlay_state_value "$state_file" "installed_by_setup")"
        local recorded_checksum="$(get_overlay_state_value "$state_file" "original_checksum")"

        local overlay_marked_absent="false"
        if [ -f "$absent_marker" ] || [ "$original_state" = "absent" ]; then
            overlay_marked_absent="true"
        fi

        if [ "$overlay_marked_absent" = "true" ] && [ "$installed_by_setup" = "true" ]; then
            if [ -f "$overlay_path" ]; then
                if rm -f "$overlay_path"; then
                    logMessage "Overlay $overlay (vom Setup bereitgestellt) wurde entfernt, da es ursprünglich fehlte."
                    rebootNeeded=true
                    logMessage "Neustartbedarf gesetzt, da Overlay $overlay entfernt wurde."
                    set_overlay_state_value "$state_file" "last_action" "removed_setup_overlay"
                else
                    logMessage "Fehler beim Entfernen von Overlay $overlay."
                    setInstallFailed $EXIT_ERROR "Fehler beim Entfernen von Overlay $overlay."
                fi
            else
                logMessage "Overlay $overlay war bereits entfernt; keine Aktion erforderlich."
                set_overlay_state_value "$state_file" "last_action" "already_absent"
            fi
            rm -f "$backup_file"
            set_overlay_state_value "$state_file" "installed_by_setup" "false"
            continue
        fi

        if [ -f "$backup_file" ]; then
            if cp "$backup_file" "$overlay_path"; then
                logMessage "Overlay $overlay wurde auf den ursprünglichen Zustand zurückgesetzt (Checksumme: ${recorded_checksum:-unbekannt})."
                rebootNeeded=true
                logMessage "Neustartbedarf gesetzt, da Overlay $overlay aus der Sicherung wiederhergestellt wurde."
                set_overlay_state_value "$state_file" "installed_by_setup" "false"
                set_overlay_state_value "$state_file" "last_action" "restored_from_backup"
                rm -f "$absent_marker"
            else
                logMessage "Fehler beim Wiederherstellen von Overlay $overlay aus der Sicherung."
                setInstallFailed $EXIT_ERROR "Fehler beim Wiederherstellen von Overlay $overlay aus der Sicherung."
            fi
        else
            if [ "$installed_by_setup" = "true" ] && [ -f "$absent_marker" ]; then
                if [ -f "$overlay_path" ]; then
                    if rm -f "$overlay_path"; then
                        logMessage "Overlay $overlay (vom Setup bereitgestellt) wurde entfernt, da es ursprünglich fehlte."
                        rebootNeeded=true
                        logMessage "Neustartbedarf gesetzt, da Overlay $overlay entfernt wurde."
                        set_overlay_state_value "$state_file" "last_action" "removed_setup_overlay"
                    else
                        logMessage "Fehler beim Entfernen von Overlay $overlay."
                        setInstallFailed $EXIT_ERROR "Fehler beim Entfernen von Overlay $overlay."
                    fi
                else
                    logMessage "Overlay $overlay war bereits entfernt; keine Aktion erforderlich."
                    set_overlay_state_value "$state_file" "last_action" "already_absent"
                fi
                set_overlay_state_value "$state_file" "installed_by_setup" "false"
            else
                if [ -f "$overlay_path" ]; then
                    if [ "$original_state" = "present" ]; then
                        logMessage "Overlay $overlay bleibt unverändert, da es nicht vom Setup verwaltet wurde."
                    else
                        logMessage "Overlay $overlay bleibt bestehen; keine Sicherung oder Setup-Verwaltung vorhanden."
                    fi
                    set_overlay_state_value "$state_file" "last_action" "left_untouched"
                else
                    logMessage "Overlay $overlay ist nicht vorhanden; keine Aktion erforderlich."
                    set_overlay_state_value "$state_file" "last_action" "not_present"
                fi
            fi
        fi
    done
    logMessage "Overlay-Verarbeitung abgeschlossen."
}

## Kernel-Module prüfen und installieren bzw. deinstallieren
# Kernel-Module prüfen und installieren
check_and_install_kernel_modules() {
    logMessage "Prüfe und installiere Kernel-Module..."
    local missing_modules=()
    local newly_installed=()

    for module in "${REQUIRED_MODULES[@]}"; do
        if opkg list-installed | grep -q "$module"; then
            logMessage "$module ist bereits installiert und bleibt unverändert."
        else
            missing_modules+=("$module")
        fi
    done

    if [ ${#missing_modules[@]} -eq 0 ]; then
        return
    fi

    if [ "$OPKG_UPDATE_PERFORMED" != "true" ]; then
        logMessage "Aktualisiere Paketquellen..."
        if ! opkg update; then
            logMessage "Fehler bei der Aktualisierung der Paketquellen."
            setInstallFailed $EXIT_ERROR "Fehler bei der Aktualisierung der Paketquellen."
            return
        fi
        OPKG_UPDATE_PERFORMED=true
    else
        logMessage "Paketquellen bereits aktualisiert; überspringe erneutes opkg update."
    fi

    for module in "${missing_modules[@]}"; do
        logMessage "Installiere $module..."
        if opkg install "$module"; then
            logMessage "$module installiert."
            rebootNeeded=true
            if [ ! -d "$MODULE_STATE_DIR" ]; then
                mkdir -p "$MODULE_STATE_DIR"
            fi
            if [ ! -f "$MODULE_TRACK_FILE" ]; then
                : > "$MODULE_TRACK_FILE"
            fi
            if ! grep -Fxq "$module" "$MODULE_TRACK_FILE"; then
                echo "$module" >> "$MODULE_TRACK_FILE"
                logMessage "$module wurde für eine spätere Deinstallation markiert."
            else
                logMessage "$module war bereits als durch das Setup installiert markiert."
            fi
            newly_installed+=("$module")
        else
            logMessage "Fehler bei der Installation von $module."
            setInstallFailed $EXIT_ERROR "Fehler bei der Installation von $module."
        fi
    done

    if [ ${#newly_installed[@]} -gt 0 ]; then
        logMessage "Neu installierte Kernel-Module: ${newly_installed[*]}"
    else
        logMessage "Keine neuen Kernel-Module erforderlich; bestehende Installationen bleiben erhalten."
    fi
}

# Kernel-Module deinstallieren
remove_kernel_modules() {
    logMessage "Entferne Kernel-Module, die vom Setup installiert wurden..."

    if [ ! -f "$MODULE_TRACK_FILE" ]; then
        for module in "${REQUIRED_MODULES[@]}"; do
            logMessage "Modul $module wurde nicht zum Entfernen markiert und bleibt unverändert."
        done
        logMessage "Keine markierten Kernel-Module gefunden; es wurde nichts entfernt."
        return
    fi

    local marked_modules=()
    mapfile -t marked_modules < "$MODULE_TRACK_FILE"

    local filtered_marked=()
    local entry
    for entry in "${marked_modules[@]}"; do
        if [ -n "$entry" ]; then
            filtered_marked+=("$entry")
        fi
    done
    marked_modules=("${filtered_marked[@]}")

    if [ ${#marked_modules[@]} -eq 0 ]; then
        for module in "${REQUIRED_MODULES[@]}"; do
            logMessage "Modul $module wurde nicht zum Entfernen markiert und bleibt unverändert."
        done
        logMessage "Die Markierungsliste ist leer; es wurde nichts entfernt."
        return
    fi

    local removed_modules=()
    local failed_removals=()
    local already_absent_modules=()

    for module in "${marked_modules[@]}"; do
        if opkg list-installed | grep -q "$module"; then
            logMessage "Entferne markiertes Modul $module..."
            if opkg remove "$module"; then
                logMessage "$module entfernt."
                removed_modules+=("$module")
                rebootNeeded=true
            else
                logMessage "Fehler beim Entfernen von $module."
                setInstallFailed $EXIT_ERROR "Fehler beim Entfernen von $module."
                failed_removals+=("$module")
            fi
        else
            logMessage "Markiertes Modul $module ist nicht installiert und bleibt unverändert."
            already_absent_modules+=("$module")
        fi
    done

    if [ ${#removed_modules[@]} -gt 0 ] || [ ${#already_absent_modules[@]} -gt 0 ]; then
        local remaining_marked=()
        for module in "${marked_modules[@]}"; do
            local remove_entry=0
            for removed in "${removed_modules[@]}"; do
                if [ "$module" = "$removed" ]; then
                    remove_entry=1
                    break
                fi
            done
            if [ "$remove_entry" -eq 0 ]; then
                local missing_entry=0
                for missing in "${already_absent_modules[@]}"; do
                    if [ "$module" = "$missing" ]; then
                        missing_entry=1
                        break
                    fi
                done
                if [ "$missing_entry" -eq 0 ]; then
                    remaining_marked+=("$module")
                fi
            fi
        done

        if [ ${#remaining_marked[@]} -gt 0 ]; then
            printf '%s\n' "${remaining_marked[@]}" > "$MODULE_TRACK_FILE"
        else
            rm -f "$MODULE_TRACK_FILE"
        fi
    fi

    if [ ${#removed_modules[@]} -gt 0 ]; then
        logMessage "Folgende markierte Module wurden entfernt: ${removed_modules[*]}"
    else
        logMessage "Es wurden keine markierten Module entfernt."
    fi

    if [ ${#already_absent_modules[@]} -gt 0 ]; then
        logMessage "Folgende markierte Module waren bereits nicht installiert: ${already_absent_modules[*]}"
    fi

    if [ ${#failed_removals[@]} -gt 0 ]; then
        logMessage "Folgende markierte Module konnten nicht entfernt werden und bleiben installiert: ${failed_removals[*]}"
    fi

    local unmarked_modules=()
    for module in "${REQUIRED_MODULES[@]}"; do
        local is_marked=0
        for marked in "${marked_modules[@]}"; do
            if [ "$module" = "$marked" ]; then
                is_marked=1
                break
            fi
        done
        if [ "$is_marked" -eq 0 ]; then
            unmarked_modules+=("$module")
        fi
    done

    if [ ${#unmarked_modules[@]} -gt 0 ]; then
        logMessage "Folgende Module wurden nicht zum Entfernen markiert und bleiben erhalten: ${unmarked_modules[*]}"
    fi
}

## rc.local einrichten und zurücksetzen
# rc.local einrichten
setup_rc_local() {
    logMessage "Richte rc.local ein..."
    add_entry_to_rc_local "echo ds1307 0x68 > /sys/class/i2c-adapter/i2c-1/new_device"
    add_entry_to_rc_local "hwclock -s"
}

# rc.local zurücksetzen
reset_rc_local() {
    logMessage "Setze rc.local zurück..."
    if [ ! -f "$RC_LOCAL_FILE" ]; then
        logMessage "rc.local ist nicht vorhanden; es wurden keine Änderungen vorgenommen."
        return
    fi

    if [ "$rcLocalRestorePerformed" = true ]; then
        logMessage "rc.local wurde bereits unverändert aus der Sicherung übernommen; keine weitere Bereinigung erforderlich."
        return
    fi

    local entries=(
        "echo ds1307 0x68 > /sys/class/i2c-adapter/i2c-1/new_device"
        "hwclock -s"
    )
    local backup_exists=false
    if [ "$rcLocalBackupAvailable" = true ] || [ -f "$RC_LOCAL_BACKUP" ]; then
        backup_exists=true
    fi

    if [ "$backup_exists" = true ]; then
        logMessage "Sicherung der rc.local ist vorhanden; vergleiche mit bekannten Setup-Einträgen."
    else
        logMessage "Keine Sicherung der rc.local verfügbar; nutze Setup-Markierungen zur Bereinigung."
    fi

    local removed_entries=()
    local kept_entries=()
    local absent_entries=()

    local entry
    for entry in "${entries[@]}"; do
        if ! grep -qF -- "$entry" "$RC_LOCAL_FILE"; then
            logMessage "rc.local Eintrag \"$entry\" ist nicht vorhanden; keine Aktion erforderlich."
            absent_entries+=("$entry")
            continue
        fi

        local present_in_backup=0
        if [ "$backup_exists" = true ] && grep -qF -- "$entry" "$RC_LOCAL_BACKUP"; then
            present_in_backup=1
        fi

        local marked_by_setup=0
        if [ -f "$RC_LOCAL_STATE_FILE" ] && grep -qFx -- "$entry" "$RC_LOCAL_STATE_FILE"; then
            marked_by_setup=1
        fi

        if [ "$present_in_backup" -eq 1 ]; then
            logMessage "rc.local Eintrag \"$entry\" bleibt bestehen, da er bereits in der Sicherung enthalten war."
            kept_entries+=("$entry")
            continue
        fi

        local removal_reasons=()
        local removal_allowed=false
        if [ "$backup_exists" = false ]; then
            removal_allowed=true
            removal_reasons+=("keine Sicherung verfügbar")
        fi
        if [ "$marked_by_setup" -eq 1 ]; then
            removal_allowed=true
            removal_reasons+=("Setup-Markierung")
        fi
        if [ "$backup_exists" = true ] && [ "$present_in_backup" -eq 0 ]; then
            removal_allowed=true
            removal_reasons+=("nicht in Sicherung enthalten")
        fi

        if [ "$removal_allowed" = true ]; then
            remove_entry_from_rc_local "$entry"
            local removal_reason="${removal_reasons[0]}"
            if [ ${#removal_reasons[@]} -gt 1 ]; then
                local reason_index
                for reason_index in "${removal_reasons[@]:1}"; do
                    removal_reason+=", ${reason_index}"
                done
            fi
            logMessage "rc.local Eintrag \"$entry\" wurde entfernt (${removal_reason})."
            removed_entries+=("$entry")
            if [ -f "$RC_LOCAL_STATE_FILE" ]; then
                local escaped_entry
                escaped_entry=$(printf '%s\n' "$entry" | sed 's/[\/&]/\\&/g')
                sed -i "/^${escaped_entry}$/d" "$RC_LOCAL_STATE_FILE"
            fi
        else
            logMessage "rc.local Eintrag \"$entry\" bleibt bestehen, da kein Nachweis für eine Setup-Herkunft vorliegt."
            kept_entries+=("$entry")
        fi
    done

    if [ -f "$RC_LOCAL_STATE_FILE" ] && [ ! -s "$RC_LOCAL_STATE_FILE" ]; then
        rm -f "$RC_LOCAL_STATE_FILE"
    fi

    if [ ${#removed_entries[@]} -gt 0 ]; then
        logMessage "Folgende rc.local Einträge wurden entfernt: ${removed_entries[*]}"
        logMessage "rc.local wurde gezielt um Setup-Einträge bereinigt."
    else
        logMessage "Es wurden keine rc.local Einträge entfernt."
        logMessage "rc.local blieb nach der Prüfung unverändert."
    fi

    if [ ${#kept_entries[@]} -gt 0 ]; then
        logMessage "Folgende rc.local Einträge blieben erhalten: ${kept_entries[*]}"
    fi

    if [ ${#absent_entries[@]} -gt 0 ]; then
        logMessage "Folgende erwartete rc.local Einträge waren bereits entfernt: ${absent_entries[*]}"
    fi
}

case "$scriptAction" in
    INSTALL|CHECK)
        backup_originals
        install_config
        check_and_restore_overlays
        check_and_install_kernel_modules
        setup_rc_local
        ;;
    UNINSTALL)
        restore_originals
        uninstall_config
        remove_overlays
        remove_kernel_modules
        reset_rc_local
        ;;
    *)
        logMessage "Keine spezifische Aktion angegeben. Führe Standardinstallation durch..."
        backup_originals
        install_config
        check_and_restore_overlays
        check_and_install_kernel_modules
        setup_rc_local
        ;;
esac

logMessage "Skriptausführung abgeschlossen."
endScript
