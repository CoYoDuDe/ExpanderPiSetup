#!/bin/bash

# Setup-Skript für ExpanderPiSetup
# Einbinden der Helper-Ressourcen
source "/data/SetupHelper/HelperResources/IncludeHelpers"

# Standardaktionen aktivieren
standardPromptAndActions='yes'

# Installationsverzeichnis festlegen
ROOT_PATH=/data/ExpanderPiSetup

# Pfaddefinitionen
CONFIG_FILE="/etc/venus/dbus-adc.conf"
SOURCE_CONFIG_FILE="${ROOT_PATH}/FileSets/configs/dbus-adc.conf"
BACKUP_CONFIG_FILE="${CONFIG_FILE}.orig"
SOURCE_FILE_DIR="${ROOT_PATH}/FileSets"
OVERLAYS=("i2c-rtc.dtbo" "ds1307-rtc.dtbo" "mcp3208.dtbo")
OVERLAY_DIR="/u-boot/overlays"
OVERLAY_STATE_DIR="${ROOT_PATH}/overlay_state"
CONFIG_TXT="/u-boot/config.txt"
CONFIG_TXT_BACKUP="/u-boot/config.txt.orig"
REQUIRED_MODULES=("kernel-module-rtc-ds1307" "kernel-module-mcp320x")
MODULE_STATE_DIR="${ROOT_PATH}/state"
MODULE_TRACK_FILE="${MODULE_STATE_DIR}/installed_kernel_modules.list"
RC_LOCAL_FILE="/data/rc.local"
RC_LOCAL_BACKUP="/data/rc.local.orig"
RC_LOCAL_CONTENT="echo ds1307 0x68 > /sys/class/i2c-adapter/i2c-1/new_device\nhwclock -s"

# Status, ob "opkg update" bereits erfolgreich ausgeführt wurde
OPKG_UPDATE_PERFORMED=false

# Statusflags für Sicherungen und Wiederherstellungen
configBackupExisted=false
[ -f "$BACKUP_CONFIG_FILE" ] && configBackupExisted=true
configRestorePerformed=false

# Kompatibilität prüfen
if [ ! -f /etc/venus/machine ]; then
    logMessage "Kann den Venus-Gerätetyp nicht bestimmen - Skript wird beendet."
    setInstallFailed $EXIT_INCOMPATIBLE_PLATFORM "Kann den Venus-Gerätetyp nicht bestimmen."
fi

machine=$(cat /etc/venus/machine)
if [[ "$machine" != "raspberrypi2" && "$machine" != "raspberrypi4" ]]; then
    logMessage "$machine wird nicht unterstützt - Skript wird beendet."
    setInstallFailed $EXIT_INCOMPATIBLE_PLATFORM "$machine wird nicht unterstützt."
fi

# Funktionen definieren

## Einträge in rc.local hinzufügen und entfernen
# Eintrag in rc.local hinzufügen
add_entry_to_rc_local() {
    local ENTRY="$1"
    if [ ! -f "$RC_LOCAL_FILE" ]; then
        echo "$ENTRY" > "$RC_LOCAL_FILE"
    else
        if ! grep -qF "$ENTRY" "$RC_LOCAL_FILE"; then
            echo "$ENTRY" >> "$RC_LOCAL_FILE"
        fi
    fi
    chmod +x "$RC_LOCAL_FILE"
}

# Eintrag aus rc.local entfernen
remove_entry_from_rc_local() {
    local ENTRY="$1"
    [ -f "$RC_LOCAL_FILE" ] && sed -i "/^$(echo "$ENTRY" | sed 's/[\/&]/\\&/g')$/d" "$RC_LOCAL_FILE"
}

# Hilfsfunktionen zum Verwalten des Overlay-Status
set_overlay_state_value() {
    local state_file="$1"
    local key="$2"
    local value="$3"

    if [ -f "$state_file" ]; then
        if grep -q "^${key}=" "$state_file"; then
            sed -i "s/^${key}=.*/${key}=${value}/" "$state_file"
            return
        fi
    fi

    mkdir -p "$(dirname "$state_file")"
    echo "${key}=${value}" >> "$state_file"
}

get_overlay_state_value() {
    local state_file="$1"
    local key="$2"

    if [ -f "$state_file" ]; then
        grep -E "^${key}=" "$state_file" | tail -n1 | cut -d'=' -f2-
    fi
}

## Originaldateien sichern und wiederherstellen
# Originaldateien sichern
backup_originals() {
    logMessage "Sichere Originaldateien..."
    backupFile "$CONFIG_FILE" "$BACKUP_CONFIG_FILE"
    [ -f "$BACKUP_CONFIG_FILE" ] && configBackupExisted=true
    backupFile "$CONFIG_TXT" "$CONFIG_TXT_BACKUP"
    backupFile "$RC_LOCAL_FILE" "$RC_LOCAL_BACKUP"

    mkdir -p "$OVERLAY_STATE_DIR"
    for overlay in "${OVERLAYS[@]}"; do
        local overlay_path="$OVERLAY_DIR/$overlay"
        local state_file="$OVERLAY_STATE_DIR/${overlay}.state"
        local backup_file="$OVERLAY_STATE_DIR/${overlay}.orig"
        local absent_marker="$OVERLAY_STATE_DIR/${overlay}.absent"
        local timestamp="$(date -u +"%Y-%m-%dT%H:%M:%SZ")"

        rm -f "$backup_file" "$absent_marker"
        : > "$state_file"

        if [ -f "$overlay_path" ]; then
            if cp "$overlay_path" "$backup_file"; then
                local checksum="unbekannt"
                if command -v sha256sum >/dev/null 2>&1; then
                    checksum="$(sha256sum "$overlay_path" | awk '{print $1}')"
                fi
                logMessage "Overlay $overlay wurde gesichert (Checksumme: $checksum)."
                set_overlay_state_value "$state_file" "original" "present"
                set_overlay_state_value "$state_file" "original_checksum" "$checksum"
                set_overlay_state_value "$state_file" "original_recorded_at" "$timestamp"
            else
                logMessage "Fehler beim Sichern von Overlay $overlay."
                setInstallFailed $EXIT_ERROR "Fehler beim Sichern von Overlay $overlay."
            fi
        else
            logMessage "Overlay $overlay war vor der Installation nicht vorhanden. Markiere Zustand als 'absent'."
            : > "$absent_marker"
            set_overlay_state_value "$state_file" "original" "absent"
            set_overlay_state_value "$state_file" "original_checksum" "nicht_vorhanden"
            set_overlay_state_value "$state_file" "original_recorded_at" "$timestamp"
        fi

        set_overlay_state_value "$state_file" "installed_by_setup" "false"
        set_overlay_state_value "$state_file" "last_action" "backup_recorded"
    done
}

# Originaldateien wiederherstellen
restore_originals() {
    logMessage "Stelle Originaldateien wieder her..."
    if restoreFile "$BACKUP_CONFIG_FILE" "$CONFIG_FILE"; then
        configRestorePerformed=true
        logMessage "Originale dbus-adc.conf wurde erfolgreich wiederhergestellt."
    else
        configRestorePerformed=false
        if [ -f "$BACKUP_CONFIG_FILE" ]; then
            logMessage "Warnung: Wiederherstellung der dbus-adc.conf aus der Sicherung ist fehlgeschlagen."
        else
            logMessage "Keine Sicherung der dbus-adc.conf gefunden; Setup-Version bleibt bestehen."
        fi
    fi

    if [ -f "$BACKUP_CONFIG_FILE" ]; then
        configBackupExisted=true
    else
        configBackupExisted=false
    fi

    restoreFile "$CONFIG_TXT_BACKUP" "$CONFIG_TXT"
    restoreFile "$RC_LOCAL_BACKUP" "$RC_LOCAL_FILE"
}

## Konfigurationsdateien installieren und deinstallieren
# Konfigurationsdateien installieren
install_config() {
    logMessage "Installiere dbus-adc.conf..."
    if [ -f "$SOURCE_CONFIG_FILE" ]; then
        if ! cmp -s "$SOURCE_CONFIG_FILE" "$CONFIG_FILE"; then
            cp "$SOURCE_CONFIG_FILE" "$CONFIG_FILE"
            logMessage "dbus-adc.conf erfolgreich installiert."
            filesUpdated=true
        else
            logMessage "dbus-adc.conf ist bereits aktuell."
        fi
    else
        logMessage "Fehler: dbus-adc.conf Quelle nicht gefunden."
        setInstallFailed $EXIT_FILE_SET_ERROR "Fehler: dbus-adc.conf Quelle nicht gefunden."
    fi

    logMessage "Aktualisiere $CONFIG_TXT..."
    if ! grep -q "dtoverlay=i2c-rtc,ds1307-rtc" "$CONFIG_TXT"; then
        echo "dtoverlay=i2c-rtc,ds1307-rtc" >> "$CONFIG_TXT"
        filesUpdated=true
    fi
    if ! grep -q "dtoverlay=mcp3208:spi0-0-present" "$CONFIG_TXT"; then
        echo "dtoverlay=mcp3208:spi0-0-present" >> "$CONFIG_TXT"
        filesUpdated=true
    fi

    logMessage "$CONFIG_TXT aktualisiert."
    rebootNeeded=true
}

# Konfigurationsdateien deinstallieren
uninstall_config() {
    logMessage "Entferne Konfigurationsdateien..."
    sed -i '/dtoverlay=i2c-rtc,ds1307-rtc/d' "$CONFIG_TXT"
    sed -i '/dtoverlay=mcp3208:spi0-0-present/d' "$CONFIG_TXT"

    remove_entry_from_rc_local "echo ds1307 0x68 > /sys/class/i2c-adapter/i2c-1/new_device"
    remove_entry_from_rc_local "hwclock -s"

    local backup_file_present=false
    [ -f "$BACKUP_CONFIG_FILE" ] && backup_file_present=true

    if [ "$configRestorePerformed" = true ]; then
        if [ -f "$CONFIG_FILE" ]; then
            logMessage "Originale dbus-adc.conf wurde wiederhergestellt und bleibt erhalten."
        else
            logMessage "Warnung: Wiederhergestellte dbus-adc.conf wurde nicht gefunden."
        fi

        if [ "$backup_file_present" = true ]; then
            logMessage "Sicherungsdatei dbus-adc.conf.orig ist weiterhin vorhanden."
        else
            logMessage "Sicherungsdatei dbus-adc.conf.orig wurde bereits entfernt."
        fi
    else
        if [ "$backup_file_present" = true ]; then
            logMessage "Sicherungsdatei dbus-adc.conf.orig ist vorhanden, konnte jedoch nicht wiederhergestellt werden."
        else
            logMessage "Keine Sicherung der dbus-adc.conf verfügbar; entferne Setup-Version."
        fi

        if [ -f "$CONFIG_FILE" ]; then
            if rm -f "$CONFIG_FILE"; then
                logMessage "dbus-adc.conf aus dem Setup wurde entfernt."
            else
                logMessage "Fehler beim Entfernen der dbus-adc.conf."
                setInstallFailed $EXIT_ERROR "Fehler beim Entfernen der dbus-adc.conf."
            fi
        else
            logMessage "dbus-adc.conf war nicht vorhanden und musste nicht entfernt werden."
        fi
    fi

    logMessage "Konfigurationsdateien deinstalliert."
}

## Overlays prüfen und wiederherstellen bzw. entfernen
# Overlays prüfen und wiederherstellen
check_and_restore_overlays() {
    logMessage "Prüfe und stelle Overlays wieder her..."
    for overlay in "${OVERLAYS[@]}"; do
        local state_file="$OVERLAY_STATE_DIR/${overlay}.state"
        if [ ! -f "$OVERLAY_DIR/$overlay" ]; then
            logMessage "Overlay $overlay fehlt. Wiederherstellung aus $SOURCE_FILE_DIR/overlays..."
            if [ -f "$SOURCE_FILE_DIR/overlays/$overlay" ]; then
                if cp "$SOURCE_FILE_DIR/overlays/$overlay" "$OVERLAY_DIR/"; then
                    logMessage "Overlay $overlay erfolgreich wiederhergestellt."
                    set_overlay_state_value "$state_file" "installed_by_setup" "true"
                    rebootNeeded=true
                else
                    logMessage "Fehler beim Wiederherstellen von Overlay $overlay."
                    setInstallFailed $EXIT_ERROR "Fehler beim Wiederherstellen von Overlay $overlay."
                fi
            else
                logMessage "Fehler: Quelle für Overlay $overlay nicht gefunden."
                setInstallFailed $EXIT_FILE_SET_ERROR "Fehler: Quelle für Overlay $overlay nicht gefunden."
            fi
        else
            logMessage "Overlay $overlay ist bereits vorhanden."
        fi
    done
}

# Overlays entfernen
remove_overlays() {
    logMessage "Entferne oder stelle Overlays wieder her..."
    for overlay in "${OVERLAYS[@]}"; do
        local overlay_path="$OVERLAY_DIR/$overlay"
        local state_file="$OVERLAY_STATE_DIR/${overlay}.state"
        local backup_file="$OVERLAY_STATE_DIR/${overlay}.orig"
        local absent_marker="$OVERLAY_STATE_DIR/${overlay}.absent"
        local original_state="$(get_overlay_state_value "$state_file" "original")"
        local installed_by_setup="$(get_overlay_state_value "$state_file" "installed_by_setup")"
        local recorded_checksum="$(get_overlay_state_value "$state_file" "original_checksum")"

        if [ -f "$backup_file" ]; then
            if cp "$backup_file" "$overlay_path"; then
                logMessage "Overlay $overlay wurde auf den ursprünglichen Zustand zurückgesetzt (Checksumme: ${recorded_checksum:-unbekannt})."
                set_overlay_state_value "$state_file" "installed_by_setup" "false"
                set_overlay_state_value "$state_file" "last_action" "restored_from_backup"
                rm -f "$absent_marker"
            else
                logMessage "Fehler beim Wiederherstellen von Overlay $overlay aus der Sicherung."
                setInstallFailed $EXIT_ERROR "Fehler beim Wiederherstellen von Overlay $overlay aus der Sicherung."
            fi
        else
            if [ "$installed_by_setup" = "true" ] && [ -f "$absent_marker" ]; then
                if [ -f "$overlay_path" ]; then
                    if rm -f "$overlay_path"; then
                        logMessage "Overlay $overlay (vom Setup bereitgestellt) wurde entfernt, da es ursprünglich fehlte."
                        set_overlay_state_value "$state_file" "last_action" "removed_setup_overlay"
                    else
                        logMessage "Fehler beim Entfernen von Overlay $overlay."
                        setInstallFailed $EXIT_ERROR "Fehler beim Entfernen von Overlay $overlay."
                    fi
                else
                    logMessage "Overlay $overlay war bereits entfernt; keine Aktion erforderlich."
                    set_overlay_state_value "$state_file" "last_action" "already_absent"
                fi
                set_overlay_state_value "$state_file" "installed_by_setup" "false"
            else
                if [ -f "$overlay_path" ]; then
                    if [ "$original_state" = "present" ]; then
                        logMessage "Overlay $overlay bleibt unverändert, da es nicht vom Setup verwaltet wurde."
                    else
                        logMessage "Overlay $overlay bleibt bestehen; keine Sicherung oder Setup-Verwaltung vorhanden."
                    fi
                    set_overlay_state_value "$state_file" "last_action" "left_untouched"
                else
                    logMessage "Overlay $overlay ist nicht vorhanden; keine Aktion erforderlich."
                    set_overlay_state_value "$state_file" "last_action" "not_present"
                fi
            fi
        fi
    done
    logMessage "Overlay-Verarbeitung abgeschlossen."
}

## Kernel-Module prüfen und installieren bzw. deinstallieren
# Kernel-Module prüfen und installieren
check_and_install_kernel_modules() {
    logMessage "Prüfe und installiere Kernel-Module..."
    local missing_modules=()
    local newly_installed=()

    for module in "${REQUIRED_MODULES[@]}"; do
        if opkg list-installed | grep -q "$module"; then
            logMessage "$module ist bereits installiert und bleibt unverändert."
        else
            missing_modules+=("$module")
        fi
    done

    if [ ${#missing_modules[@]} -eq 0 ]; then
        return
    fi

    if [ "$OPKG_UPDATE_PERFORMED" != "true" ]; then
        logMessage "Aktualisiere Paketquellen..."
        if ! opkg update; then
            logMessage "Fehler bei der Aktualisierung der Paketquellen."
            setInstallFailed $EXIT_ERROR "Fehler bei der Aktualisierung der Paketquellen."
            return
        fi
        OPKG_UPDATE_PERFORMED=true
    else
        logMessage "Paketquellen bereits aktualisiert; überspringe erneutes opkg update."
    fi

    for module in "${missing_modules[@]}"; do
        logMessage "Installiere $module..."
        if opkg install "$module"; then
            logMessage "$module installiert."
            rebootNeeded=true
            if [ ! -d "$MODULE_STATE_DIR" ]; then
                mkdir -p "$MODULE_STATE_DIR"
            fi
            if [ ! -f "$MODULE_TRACK_FILE" ]; then
                : > "$MODULE_TRACK_FILE"
            fi
            if ! grep -Fxq "$module" "$MODULE_TRACK_FILE"; then
                echo "$module" >> "$MODULE_TRACK_FILE"
                logMessage "$module wurde für eine spätere Deinstallation markiert."
            else
                logMessage "$module war bereits als durch das Setup installiert markiert."
            fi
            newly_installed+=("$module")
        else
            logMessage "Fehler bei der Installation von $module."
            setInstallFailed $EXIT_ERROR "Fehler bei der Installation von $module."
        fi
    done

    if [ ${#newly_installed[@]} -gt 0 ]; then
        logMessage "Neu installierte Kernel-Module: ${newly_installed[*]}"
    else
        logMessage "Keine neuen Kernel-Module erforderlich; bestehende Installationen bleiben erhalten."
    fi
}

# Kernel-Module deinstallieren
remove_kernel_modules() {
    logMessage "Entferne Kernel-Module, die vom Setup installiert wurden..."

    if [ ! -f "$MODULE_TRACK_FILE" ]; then
        for module in "${REQUIRED_MODULES[@]}"; do
            logMessage "Modul $module wurde nicht zum Entfernen markiert und bleibt unverändert."
        done
        logMessage "Keine markierten Kernel-Module gefunden; es wurde nichts entfernt."
        return
    fi

    local marked_modules=()
    mapfile -t marked_modules < "$MODULE_TRACK_FILE"

    local filtered_marked=()
    local entry
    for entry in "${marked_modules[@]}"; do
        if [ -n "$entry" ]; then
            filtered_marked+=("$entry")
        fi
    done
    marked_modules=("${filtered_marked[@]}")

    if [ ${#marked_modules[@]} -eq 0 ]; then
        for module in "${REQUIRED_MODULES[@]}"; do
            logMessage "Modul $module wurde nicht zum Entfernen markiert und bleibt unverändert."
        done
        logMessage "Die Markierungsliste ist leer; es wurde nichts entfernt."
        return
    fi

    local removed_modules=()
    local failed_removals=()
    local already_absent_modules=()

    for module in "${marked_modules[@]}"; do
        if opkg list-installed | grep -q "$module"; then
            logMessage "Entferne markiertes Modul $module..."
            if opkg remove "$module"; then
                logMessage "$module entfernt."
                removed_modules+=("$module")
                rebootNeeded=true
            else
                logMessage "Fehler beim Entfernen von $module."
                setInstallFailed $EXIT_ERROR "Fehler beim Entfernen von $module."
                failed_removals+=("$module")
            fi
        else
            logMessage "Markiertes Modul $module ist nicht installiert und bleibt unverändert."
            already_absent_modules+=("$module")
        fi
    done

    if [ ${#removed_modules[@]} -gt 0 ] || [ ${#already_absent_modules[@]} -gt 0 ]; then
        local remaining_marked=()
        for module in "${marked_modules[@]}"; do
            local remove_entry=0
            for removed in "${removed_modules[@]}"; do
                if [ "$module" = "$removed" ]; then
                    remove_entry=1
                    break
                fi
            done
            if [ "$remove_entry" -eq 0 ]; then
                local missing_entry=0
                for missing in "${already_absent_modules[@]}"; do
                    if [ "$module" = "$missing" ]; then
                        missing_entry=1
                        break
                    fi
                done
                if [ "$missing_entry" -eq 0 ]; then
                    remaining_marked+=("$module")
                fi
            fi
        done

        if [ ${#remaining_marked[@]} -gt 0 ]; then
            printf '%s\n' "${remaining_marked[@]}" > "$MODULE_TRACK_FILE"
        else
            rm -f "$MODULE_TRACK_FILE"
        fi
    fi

    if [ ${#removed_modules[@]} -gt 0 ]; then
        logMessage "Folgende markierte Module wurden entfernt: ${removed_modules[*]}"
    else
        logMessage "Es wurden keine markierten Module entfernt."
    fi

    if [ ${#already_absent_modules[@]} -gt 0 ]; then
        logMessage "Folgende markierte Module waren bereits nicht installiert: ${already_absent_modules[*]}"
    fi

    if [ ${#failed_removals[@]} -gt 0 ]; then
        logMessage "Folgende markierte Module konnten nicht entfernt werden und bleiben installiert: ${failed_removals[*]}"
    fi

    local unmarked_modules=()
    for module in "${REQUIRED_MODULES[@]}"; do
        local is_marked=0
        for marked in "${marked_modules[@]}"; do
            if [ "$module" = "$marked" ]; then
                is_marked=1
                break
            fi
        done
        if [ "$is_marked" -eq 0 ]; then
            unmarked_modules+=("$module")
        fi
    done

    if [ ${#unmarked_modules[@]} -gt 0 ]; then
        logMessage "Folgende Module wurden nicht zum Entfernen markiert und bleiben erhalten: ${unmarked_modules[*]}"
    fi
}

## rc.local einrichten und zurücksetzen
# rc.local einrichten
setup_rc_local() {
    logMessage "Richte rc.local ein..."
    add_entry_to_rc_local "echo ds1307 0x68 > /sys/class/i2c-adapter/i2c-1/new_device"
    add_entry_to_rc_local "hwclock -s"
}

# rc.local zurücksetzen
reset_rc_local() {
    logMessage "Setze rc.local zurück..."
    remove_entry_from_rc_local "echo ds1307 0x68 > /sys/class/i2c-adapter/i2c-1/new_device"
    remove_entry_from_rc_local "hwclock -s"
}

case "$scriptAction" in
    INSTALL|CHECK)
        backup_originals
        install_config
        check_and_restore_overlays
        check_and_install_kernel_modules
        setup_rc_local
        ;;
    UNINSTALL)
        restore_originals
        uninstall_config
        remove_overlays
        remove_kernel_modules
        reset_rc_local
        ;;
    *)
        logMessage "Keine spezifische Aktion angegeben. Führe Standardinstallation durch..."
        backup_originals
        install_config
        check_and_restore_overlays
        check_and_install_kernel_modules
        setup_rc_local
        ;;
esac

logMessage "Skriptausführung abgeschlossen."
endScript
