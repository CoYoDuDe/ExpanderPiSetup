#!/bin/bash

# Setup-Skript für ExpanderPiSetup
# Einbinden der Helper-Ressourcen
helper_resource="/data/SetupHelper/HelperResources/forSetupScript"
if [ ! -r "$helper_resource" ]; then
    echo "Fehler: SetupHelper-Ressourcen wurden nicht unter $helper_resource gefunden." >&2
    echo "Bitte SetupHelper gemäß Dokumentation installieren oder den Pfad anpassen." >&2
    exit 1
fi
if ! . "$helper_resource"; then
    echo "Fehler: Helper-Ressourcen konnten nicht geladen werden (source $helper_resource)." >&2
    echo "Bitte SetupHelper-Installation prüfen und erneut versuchen." >&2
    exit 1
fi

if ! declare -F logMessage >/dev/null 2>&1; then
    echo "Fehler: Erwartete Helper-Funktion logMessage ist nach dem Laden nicht verfügbar." >&2
    echo "Bitte SetupHelper-Installation prüfen und erneut versuchen." >&2
    exit 1
fi

# Standardaktionen aktivieren
standardPromptAndActions='yes'

# Nicht-interaktiven Modus erkennen
nonInteractiveMode=false
force_override_active=false
forced_non_interactive=""
rebootNeeded=false

if [ "${SETUPHELPER_FORCE_NONINTERACTIVE:-}" != "" ]; then
    case "${SETUPHELPER_FORCE_NONINTERACTIVE,,}" in
        1|true|yes|y|on)
            force_override_active=true
            forced_non_interactive=true
            ;;
        0|false|no|n|off)
            force_override_active=true
            forced_non_interactive=false
            ;;
        *)
            force_override_active=false
            forced_non_interactive=""
            logMessage "SETUPHELPER_FORCE_NONINTERACTIVE enthält den unbekannten Wert \"${SETUPHELPER_FORCE_NONINTERACTIVE}\" – Override wird ignoriert."
            ;;
    esac
fi

if [ "${SETUPHELPER_NONINTERACTIVE:-}" != "" ]; then
    case "${SETUPHELPER_NONINTERACTIVE,,}" in
        1|true|yes|y|on)
            nonInteractiveMode=true
            ;;
    esac
fi

if [ "$force_override_active" != true ] && [ "${SETUPHELPER_MODE:-}" != "" ]; then
    case "${SETUPHELPER_MODE,,}" in
        batch|noninteractive)
            nonInteractiveMode=true
            ;;
    esac
fi

if [ "$force_override_active" = true ] && [ "$forced_non_interactive" != "" ]; then
    nonInteractiveMode="$forced_non_interactive"
fi
skip_tty_check=false
if [ "$force_override_active" = true ] && [ "$forced_non_interactive" = false ]; then
    skip_tty_check=true
    logMessage "SETUPHELPER_FORCE_NONINTERACTIVE setzt einen interaktiven Lauf durch – TTY-Heuristik wird übersprungen."
fi

if [ "$skip_tty_check" != true ] && [ "$nonInteractiveMode" = false ] && [ ! -t 0 ]; then
    nonInteractiveMode=true
fi
if [ "$nonInteractiveMode" = true ]; then
    logMessage "Nicht-interaktiver Modus erkannt. Benutzerabfragen werden übersprungen."
fi
if [ "$force_override_active" = true ]; then
    if [ "$forced_non_interactive" = true ]; then
        logMessage "SETUPHELPER_FORCE_NONINTERACTIVE erzwingt den nicht-interaktiven Modus."
    elif [ "$forced_non_interactive" = false ]; then
        logMessage "SETUPHELPER_FORCE_NONINTERACTIVE erzwingt den interaktiven Modus trotz anderer Einstellungen."
    else
        logMessage "SETUPHELPER_FORCE_NONINTERACTIVE ist gesetzt, der Wert \"${SETUPHELPER_FORCE_NONINTERACTIVE}\" wird jedoch nicht interpretiert."
    fi
fi

# Installationsverzeichnis dynamisch aus dem Skriptpfad ableiten – bevorzugt scriptDir aus den Helper-Ressourcen
if [ -n "${scriptDir:-}" ]; then
    ROOT_PATH="$scriptDir"
else
    ROOT_PATH="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
fi

# Version für Paketierung und Logging aus zentraler Datei lesen
VERSION_FILE_PATH="${ROOT_PATH}/version"
PACKAGE_VERSION=""

if [ -f "$VERSION_FILE_PATH" ]; then
    PACKAGE_VERSION="$(head -n 1 "$VERSION_FILE_PATH" | tr -d '[:space:]')"
    if [ -n "$PACKAGE_VERSION" ]; then
        export SETUPHELPER_PACKAGE_VERSION="$PACKAGE_VERSION"
        if declare -F setScriptVersion >/dev/null 2>&1; then
            setScriptVersion "$PACKAGE_VERSION"
        elif declare -F setPackageVersion >/dev/null 2>&1; then
            setPackageVersion "$PACKAGE_VERSION"
        fi
        logMessage "Setze Paketversion auf ${PACKAGE_VERSION} gemäß ${VERSION_FILE_PATH}."
    else
        logMessage "Versionsdatei ${VERSION_FILE_PATH} ist leer – Paketversion bleibt unverändert."
    fi
else
    logMessage "Versionsdatei ${VERSION_FILE_PATH} nicht gefunden – Paketversion kann nicht gesetzt werden."
fi

# Pfaddefinitionen
CONFIG_FILE="/etc/venus/dbus-adc.conf"
BACKUP_CONFIG_FILE="${CONFIG_FILE}.orig"
SOURCE_FILE_DIR="${ROOT_PATH}/FileSets"
OVERLAYS=("i2c-rtc.dtbo" "mcp3208.dtbo")
OVERLAY_DIR="/u-boot/overlays"
OVERLAY_STATE_DIR="${ROOT_PATH}/overlay_state"
CONFIG_TXT="/u-boot/config.txt"
CONFIG_TXT_BACKUP="/u-boot/config.txt.orig"
REQUIRED_MODULES=("kernel-module-rtc-ds1307" "kernel-module-mcp320x")
MODULE_STATE_DIR="${ROOT_PATH}/state"
MODULE_TRACK_FILE="${MODULE_STATE_DIR}/installed_kernel_modules.list"
RC_LOCAL_STATE_FILE="${MODULE_STATE_DIR}/rc_local_entries.list"
RC_LOCAL_FILE="/data/rc.local"
RC_LOCAL_BACKUP="/data/rc.local.orig"
RC_LOCAL_CONTENT="hwclock -s"
LEGACY_RC_LOCAL_ENTRY="echo ds1307 0x68 > /sys/class/i2c-adapter/i2c-1/new_device"
RC_LOCAL_HW_CLOCK_ENTRY="hwclock -s"
USER_CONFIG_FILE="${ROOT_PATH}/dbus-adc.user.conf"
DEFAULT_VREF_FALLBACK="1.3"
DEFAULT_SCALE_FALLBACK="4095"
ADC_VREF_MIN="1.0"
ADC_VREF_MAX="10.0"
ADC_SCALE_MIN=1023
ADC_SCALE_MAX=65535
DEFAULT_CHANNEL_TYPES_FALLBACK=("tank" "tank" "tank" "tank" "temp" "temp" "temp" "temp")
DEFAULT_CHANNEL_LABELS_FALLBACK=("tank1" "tank2" "tank3" "tank4" "temperatur5" "temperatur6" "temperatur7" "temperatur8")
TOTAL_ADC_CHANNELS=8
ADC_DEVICE_LINE="device iio:device0"
ADC_DEVICE_DEFAULT_VALUE="${ADC_DEVICE_LINE#device }"
ADC_DEVICE_DEFAULT_VALUE="${ADC_DEVICE_DEFAULT_VALUE# }"

python_command=""

detect_python() {
    if [ -n "$python_command" ]; then
        return 0
    fi

    if command -v python3 >/dev/null 2>&1; then
        python_command="python3"
        return 0
    fi

    if command -v python >/dev/null 2>&1; then
        python_command="python"
        return 0
    fi

    return 1
}

_run_gui_configuration_loader() {
    local _python_cmd="$1"

    "$_python_cmd" <<'PY'
from __future__ import print_function

import sys

try:
    text_type = unicode  # type: ignore[name-defined]
    binary_type = str
except NameError:
    text_type = str
    binary_type = bytes


def _get_shell_quote():
    try:
        import shlex  # noqa: F401
    except ImportError:
        shlex = None

    if shlex is not None and hasattr(shlex, "quote"):
        return shlex.quote

    try:
        from pipes import quote as pipes_quote
    except ImportError:
        pipes_quote = None

    if pipes_quote is not None:
        return pipes_quote

    import re

    _find_unsafe = re.compile(r"[^\w@%+=:,./-]").search

    def _manual_quote(value):
        if value is None:
            value = ""
        else:
            value = str(value)

        if not value:
            return "''"

        if _find_unsafe(value) is None:
            return value

        return "'" + value.replace("'", "'\"'\"'") + "'"

    return _manual_quote


shell_quote = _get_shell_quote()
del _get_shell_quote


def safe_quote(value):
    if value is None:
        text = ""
    elif isinstance(value, text_type):
        text = value
    elif isinstance(value, binary_type):
        try:
            text = value.decode("utf-8", "surrogateescape")
        except Exception:
            text = value.decode("utf-8", "ignore")
    else:
        try:
            text = text_type(value)
        except Exception:
            text = str(value)

    if sys.version_info[0] < 3 and isinstance(text, text_type):
        try:
            text = text.encode("utf-8")
        except Exception:
            text = text.encode("utf-8", "ignore")

    return shell_quote(text)


try:
    import dbus
except Exception:
    sys.exit(1)

service = "com.victronenergy.settings"
root = "/Settings/ExpanderPi/DbusAdc"

bus = dbus.SystemBus()

def get_value(path):
    try:
        obj = bus.get_object(service, path)
        value = obj.GetValue(dbus_interface="com.victronenergy.BusItem")
    except Exception:
        return ""

    if value is None:
        return ""

    if isinstance(value, (dbus.Double, dbus.Int32, dbus.Int64, dbus.UInt32, dbus.UInt64)):
        return str(value)

    return str(value)

values = {}
values["EXPANDERPI_VREF"] = get_value(root + "/Vref")
values["EXPANDERPI_SCALE"] = get_value(root + "/Scale")

for idx in range(8):
    base = "{}/Channel{}".format(root, idx)
    values["EXPANDERPI_CHANNEL_{}_TYPE".format(idx)] = get_value(base + "/Type")
    values["EXPANDERPI_CHANNEL_{}_LABEL".format(idx)] = get_value(base + "/Label")

if not any(values.values()):
    sys.exit(1)

for key, val in values.items():
    print("{}={}".format(key, safe_quote(val)))
PY
}

load_gui_configuration() {
    if ! detect_python; then
        return 1
    fi

    local python_output=""
    local python_status=0
    local attempted_command="$python_command"

    python_output="$(_run_gui_configuration_loader "$python_command")"
    python_status=$?

    if [ $python_status -ne 0 ]; then
        logMessage "Interpreter $attempted_command konnte die GUI-Konfiguration nicht laden (Exit-Code $python_status)."

        if [ "$attempted_command" = "python3" ] && command -v python >/dev/null 2>&1; then
            logMessage "python3 ohne dbus – wechsle auf python"
            python_command="python"
            attempted_command="$python_command"
            python_output="$(_run_gui_configuration_loader "$python_command")"
            python_status=$?
        elif [ "$attempted_command" = "python3" ]; then
            logMessage "python3 schlug fehl, ein alternativer python-Interpreter ist jedoch nicht verfügbar."
        fi
    fi

    if [ $python_status -ne 0 ] || [ -z "$python_output" ]; then
        if [ $python_status -ne 0 ]; then
            logMessage "GUI-Konfiguration konnte nicht geladen werden mit $attempted_command (Exit-Code $python_status)."
        else
            logMessage "GUI-Konfiguration konnte nicht geladen werden mit $attempted_command (leere Ausgabe)."
        fi
        return 1
    fi

    logMessage "GUI-Konfiguration erfolgreich mit $attempted_command geladen."
    eval "$python_output"
    return 0
}

strip_comments_outside_quotes_shell() {
    local input="$1"
    local length="${#input}"
    local in_single=0
    local in_double=0
    local escaped=0
    local result=""
    local char=""

    for (( i=0; i<length; i++ )); do
        char="${input:i:1}"

        if [ $escaped -eq 1 ]; then
            result+="$char"
            escaped=0
            continue
        fi

        if [ "$char" = "\\" ]; then
            result+="$char"
            escaped=1
            continue
        fi

        if [ "$char" = '"' ] && [ $in_single -eq 0 ]; then
            result+="$char"
            if [ $in_double -eq 1 ]; then
                in_double=0
            else
                in_double=1
            fi
            continue
        fi

        if [ "$char" = "'" ] && [ $in_double -eq 0 ]; then
            result+="$char"
            if [ $in_single -eq 1 ]; then
                in_single=0
            else
                in_single=1
            fi
            continue
        fi

        if [ "$char" = "#" ] && [ $in_single -eq 0 ] && [ $in_double -eq 0 ]; then
            break
        fi

        result+="$char"
    done

    printf '%s' "$result"
}

strip_comments_outside_quotes() {
    local input="$1"

    if [ -z "${_STRIP_COMMENTS_INTERPRETER:-}" ]; then
        if command -v python3 >/dev/null 2>&1; then
            _STRIP_COMMENTS_INTERPRETER="python3"
        elif command -v python >/dev/null 2>&1; then
            _STRIP_COMMENTS_INTERPRETER="python"
        else
            _STRIP_COMMENTS_INTERPRETER="shell"
        fi
    fi

    if [ "$_STRIP_COMMENTS_INTERPRETER" = "shell" ]; then
        strip_comments_outside_quotes_shell "$input"
        return
    fi

    "$_STRIP_COMMENTS_INTERPRETER" - "$input" <<'PY'
import sys

line = sys.argv[1]
in_single = False
in_double = False
escaped = False
result = []

for char in line:
    if escaped:
        result.append(char)
        escaped = False
        continue

    if char == '\\':
        result.append(char)
        escaped = True
        continue

    if char == '"' and not in_single:
        result.append(char)
        in_double = not in_double
        continue

    if char == "'" and not in_double:
        result.append(char)
        in_single = not in_single
        continue

    if char == '#' and not in_single and not in_double:
        break

    result.append(char)

sys.stdout.write(''.join(result))
PY
}

parse_default_adc_configuration() {
    local template_file="$1"
    local -n _out_vref="$2"
    local -n _out_scale="$3"
    local -n _out_types="$4"
    local -n _out_labels="$5"
    local -n _out_device="$6"

    _out_vref=""
    _out_scale=""
    _out_types=()
    _out_labels=()
    _out_device=""

    if [ ! -f "$template_file" ]; then
        return 1
    fi

    local line=""
    local -a collected_types=()
    local -a collected_labels=()
    local read_any=false
    local pending_label=""

    while IFS= read -r line || [ -n "$line" ]; do
        local processed_line
        processed_line="$(strip_comments_outside_quotes "$line")"
        processed_line="${processed_line%$'\r'}"
        processed_line="${processed_line#${processed_line%%[![:space:]]*}}"
        processed_line="${processed_line%${processed_line##*[![:space:]]}}"

        if [ -z "$processed_line" ]; then
            continue
        fi

        read_any=true

        local -a tokens=()
        read -r -a tokens <<<"$processed_line"
        line="$processed_line"
        if [ "${#tokens[@]}" -eq 0 ]; then
            continue
        fi

        local directive="${tokens[0]}"

        case "$directive" in
            device)
                local parsed_device
                parsed_device="$(normalize_device_value "$line")"
                if [ -n "$parsed_device" ]; then
                    _out_device="$parsed_device"
                fi
                continue
                ;;
            vref)
                if [ "${#tokens[@]}" -ge 2 ]; then
                    _out_vref="${tokens[1]}"
                fi
                continue
                ;;
            scale)
                if [ "${#tokens[@]}" -ge 2 ]; then
                    _out_scale="${tokens[1]}"
                fi
                continue
                ;;
            label)
                if [ "${#tokens[@]}" -le 1 ]; then
                    pending_label=""
                    continue
                fi

                if [[ "${tokens[1]}" =~ ^[0-9]+$ ]]; then
                    local label_index="${tokens[1]}"
                    local label_text="${tokens[@]:2}"
                    if [ -n "$label_text" ]; then
                        collected_labels[label_index]="$label_text"
                    else
                        unset 'collected_labels[label_index]'
                    fi
                    pending_label=""
                else
                    pending_label="${tokens[@]:1}"
                fi
                continue
                ;;
        esac

        local type="$directive"
        local index=""
        if [ "${#tokens[@]}" -gt 1 ]; then
            index="${tokens[1]}"
        fi

        if [[ ! "$index" =~ ^[0-9]+$ ]]; then
            continue
        fi

        local label=""
        if [ "${#tokens[@]}" -gt 2 ]; then
            label="${tokens[@]:2}"
        elif [ -n "$pending_label" ]; then
            label="$pending_label"
        fi

        collected_types[index]="$type"
        if [ -n "$label" ]; then
            collected_labels[index]="$label"
        else
            unset 'collected_labels[index]'
        fi

        pending_label=""
    done <"$template_file"

    if [ "$read_any" = false ]; then
        return 1
    fi

    for (( i=0; i<TOTAL_ADC_CHANNELS; i++ )); do
        if [ -n "${collected_types[i]+set}" ]; then
            _out_types[i]="${collected_types[i]}"
            if [ -n "${collected_labels[i]+set}" ]; then
                _out_labels[i]="${collected_labels[i]}"
            else
                _out_labels[i]=""
            fi
        fi
    done

    return 0
}

# Status, ob "opkg update" bereits erfolgreich ausgeführt wurde
OPKG_UPDATE_PERFORMED=false

# Statusflags für Bereinigungen und Installationsabbruchprotokolle
cleanup_executed=false
install_abort_logged=false

# Statusflags für Sicherungen und Wiederherstellungen
configBackupExisted=false
[ -f "$BACKUP_CONFIG_FILE" ] && configBackupExisted=true
configRestorePerformed=false
configTxtRestorePerformed=false
rcLocalBackupAvailable=false
[ -f "$RC_LOCAL_BACKUP" ] && rcLocalBackupAvailable=true
rcLocalRestorePerformed=false

# Kompatibilität prüfen
abort_incompatible_platform() {
    logMessage "Abbruch wegen inkompatibler Plattform."
    endScript
    exit $EXIT_INCOMPATIBLE_PLATFORM
}

machine_file="${EXPANDERPI_MACHINE_FILE:-${VENUS_MACHINE_FILE:-/etc/venus/machine}}"

if [ ! -f "$machine_file" ]; then
    logMessage "Kann den Venus-Gerätetyp nicht bestimmen - Skript wird beendet."
    setInstallFailed $EXIT_INCOMPATIBLE_PLATFORM "Kann den Venus-Gerätetyp nicht bestimmen."
    abort_incompatible_platform
fi

machine=$(cat "$machine_file")
case "$machine" in
    raspberrypi2|raspberrypi3|raspberrypi4)
        ;;
    *)
        logMessage "$machine wird nicht unterstützt - Skript wird beendet."
        setInstallFailed $EXIT_INCOMPATIBLE_PLATFORM "$machine wird nicht unterstützt."
        abort_incompatible_platform
        ;;
esac

# Hilfsfunktion zur Erkennung des CHECK-Modus
is_check_mode() {
    [ "${scriptAction:-}" = "CHECK" ]
}

# Funktionen definieren

## Einträge in rc.local hinzufügen und entfernen
# Eintrag in rc.local hinzufügen
add_entry_to_rc_local() {
    local ENTRY="$1"
    local entry_added=0

    if [ ! -f "$RC_LOCAL_FILE" ]; then
        printf '#!/bin/sh\n\n' > "$RC_LOCAL_FILE"
    fi

    if ! grep -qF -- "$ENTRY" "$RC_LOCAL_FILE"; then
        printf '%s\n' "$ENTRY" >> "$RC_LOCAL_FILE"
        entry_added=1
    fi
    chmod +x "$RC_LOCAL_FILE"

    if [ "$entry_added" -eq 1 ]; then
        mkdir -p "$(dirname "$RC_LOCAL_STATE_FILE")"
        if [ ! -f "$RC_LOCAL_STATE_FILE" ]; then
            printf '%s\n' "$ENTRY" > "$RC_LOCAL_STATE_FILE"
        elif ! grep -qFx -- "$ENTRY" "$RC_LOCAL_STATE_FILE"; then
            printf '%s\n' "$ENTRY" >> "$RC_LOCAL_STATE_FILE"
        fi
        logMessage "rc.local Eintrag \"$ENTRY\" wurde hinzugefügt und als durch das Setup verwaltet markiert."
    else
        logMessage "rc.local Eintrag \"$ENTRY\" war bereits vorhanden und bleibt unverändert."
    fi
}

# Eintrag aus rc.local entfernen
remove_entry_from_rc_local() {
    local ENTRY="$1"
    [ -f "$RC_LOCAL_FILE" ] && sed -i "/^$(echo "$ENTRY" | sed 's/[\/&]/\\&/g')$/d" "$RC_LOCAL_FILE"
}

prune_legacy_rc_local_entries() {
    local removed_entry=false
    local removed_marker=false

    if [ -f "$RC_LOCAL_FILE" ] && grep -qF -- "$LEGACY_RC_LOCAL_ENTRY" "$RC_LOCAL_FILE"; then
        remove_entry_from_rc_local "$LEGACY_RC_LOCAL_ENTRY"
        removed_entry=true
        logMessage "Veralteten rc.local Eintrag \"$LEGACY_RC_LOCAL_ENTRY\" entfernt; Overlay übernimmt die RTC-Erstellung."
    fi

    if [ -f "$RC_LOCAL_STATE_FILE" ] && grep -qFx -- "$LEGACY_RC_LOCAL_ENTRY" "$RC_LOCAL_STATE_FILE"; then
        local escaped_entry
        escaped_entry=$(printf '%s\n' "$LEGACY_RC_LOCAL_ENTRY" | sed 's/[\\/&]/\\&/g')
        sed -i "/^${escaped_entry}$/d" "$RC_LOCAL_STATE_FILE"
        removed_marker=true
        logMessage "Setup-Markierung für den veralteten rc.local Eintrag entfernt."
    fi

    if [ "$removed_marker" = true ] && [ -f "$RC_LOCAL_STATE_FILE" ] && [ ! -s "$RC_LOCAL_STATE_FILE" ]; then
        rm -f "$RC_LOCAL_STATE_FILE"
    fi

    if [ "$removed_entry" != true ] && [ "$removed_marker" != true ]; then
        return 0
    fi

    logMessage "Legacy-rc.local-Bereinigung abgeschlossen."
}

# Hilfsfunktionen zum Verwalten des Overlay-Status
set_overlay_state_value() {
    local state_file="$1"
    local key="$2"
    local value="$3"

    if [ -f "$state_file" ]; then
        if grep -q "^${key}=" "$state_file"; then
            sed -i "s/^${key}=.*/${key}=${value}/" "$state_file"
            return
        fi
    fi

    mkdir -p "$(dirname "$state_file")"
    echo "${key}=${value}" >> "$state_file"
}

get_overlay_state_value() {
    local state_file="$1"
    local key="$2"

    if [ -f "$state_file" ]; then
        grep -E "^${key}=" "$state_file" | tail -n1 | cut -d'=' -f2-
    fi
}

## Originaldateien sichern und wiederherstellen
# Originaldateien ohne Änderungen prüfen
validate_backup_prerequisites() {
    logMessage "CHECK-Modus: Prüfe Sicherungsvoraussetzungen ohne Änderungen..."

    local check_failed=0
    local path
    local description

    for path in "$CONFIG_FILE" "$CONFIG_TXT" "$RC_LOCAL_FILE"; do
        case "$path" in
            "$CONFIG_FILE")
                description="dbus-adc.conf"
                ;;
            "$CONFIG_TXT")
                description="config.txt"
                ;;
            "$RC_LOCAL_FILE")
                description="rc.local"
                ;;
            *)
                description="Datei"
                ;;
        esac

        if [ -e "$path" ]; then
            if [ -r "$path" ]; then
                logMessage "$description (${path}) ist lesbar."
            else
                logMessage "CHECK-Modus: $description (${path}) ist nicht lesbar."
                check_failed=1
            fi
        else
            logMessage "$description (${path}) ist nicht vorhanden – keine Sicherung erforderlich."
        fi
    done

    if [ -d "$OVERLAY_DIR" ]; then
        local overlay
        for overlay in "${OVERLAYS[@]}"; do
            local overlay_path="$OVERLAY_DIR/$overlay"
            if [ -f "$overlay_path" ]; then
                if [ -r "$overlay_path" ]; then
                    logMessage "Overlay $overlay ist lesbar."
                else
                    logMessage "CHECK-Modus: Overlay $overlay (${overlay_path}) ist nicht lesbar."
                    check_failed=1
                fi
            else
                logMessage "Overlay $overlay ist nicht vorhanden und wird nicht gesichert."
            fi
        done
    else
        logMessage "CHECK-Modus: Overlay-Verzeichnis ${OVERLAY_DIR} ist nicht vorhanden."
        check_failed=1
    fi

    if [ -d "$OVERLAY_STATE_DIR" ]; then
        logMessage "Overlay-State-Verzeichnis ${OVERLAY_STATE_DIR} bleibt unangetastet."
    else
        logMessage "Overlay-State-Verzeichnis ${OVERLAY_STATE_DIR} wird im CHECK-Modus nicht erstellt."
    fi

    if [ "$check_failed" -ne 0 ]; then
        setInstallFailed $EXIT_ERROR "CHECK-Modus: Sicherungsvoraussetzungen nicht erfüllt."
        return 1
    fi

    return 0
}

# Originaldateien sichern
backup_originals() {
    logMessage "Sichere Originaldateien..."
    backupFile "$CONFIG_FILE" "$BACKUP_CONFIG_FILE"
    [ -f "$BACKUP_CONFIG_FILE" ] && configBackupExisted=true
    backupFile "$CONFIG_TXT" "$CONFIG_TXT_BACKUP"
    backupFile "$RC_LOCAL_FILE" "$RC_LOCAL_BACKUP"

    mkdir -p "$OVERLAY_STATE_DIR"
    for overlay in "${OVERLAYS[@]}"; do
        local overlay_path="$OVERLAY_DIR/$overlay"
        local state_file="$OVERLAY_STATE_DIR/${overlay}.state"
        local backup_file="$OVERLAY_STATE_DIR/${overlay}.orig"
        local absent_marker="$OVERLAY_STATE_DIR/${overlay}.absent"
        local source_overlay="$SOURCE_FILE_DIR/overlays/$overlay"
        local timestamp="$(date -u +"%Y-%m-%dT%H:%M:%SZ")"

        local previous_original_state="$(get_overlay_state_value "$state_file" "original")"
        local previous_original_checksum="$(get_overlay_state_value "$state_file" "original_checksum")"
        local previous_original_recorded_at="$(get_overlay_state_value "$state_file" "original_recorded_at")"
        local overlay_previously_absent="false"
        if [ "$previous_original_state" = "absent" ]; then
            overlay_previously_absent="true"
        fi

        local overlay_currently_present="false"
        if [ -f "$overlay_path" ]; then
            overlay_currently_present="true"
        fi

        local retain_existing_backup="false"
        if [ "$previous_original_state" = "present" ] && [ "$overlay_currently_present" = "false" ] && [ -f "$backup_file" ]; then
            retain_existing_backup="true"
        fi

        if [ "$overlay_previously_absent" = "true" ]; then
            if [ "$retain_existing_backup" != "true" ]; then
                rm -f "$backup_file"
            fi
        else
            if [ "$retain_existing_backup" != "true" ]; then
                rm -f "$backup_file"
            fi
            rm -f "$absent_marker"
        fi
        : > "$state_file"

        if [ "$overlay_previously_absent" = "true" ]; then
            if [ ! -f "$absent_marker" ]; then
                : > "$absent_marker"
            fi

            logMessage "Overlay $overlay war zuvor als 'absent' markiert. Historie wird beibehalten."
            set_overlay_state_value "$state_file" "original" "absent"
            if [ -n "$previous_original_checksum" ]; then
                set_overlay_state_value "$state_file" "original_checksum" "$previous_original_checksum"
            else
                set_overlay_state_value "$state_file" "original_checksum" "nicht_vorhanden"
            fi
            if [ -n "$previous_original_recorded_at" ]; then
                set_overlay_state_value "$state_file" "original_recorded_at" "$previous_original_recorded_at"
            else
                set_overlay_state_value "$state_file" "original_recorded_at" "$timestamp"
            fi
            set_overlay_state_value "$state_file" "installed_by_setup" "true"
            set_overlay_state_value "$state_file" "last_action" "absent_preserved"
        elif [ "$retain_existing_backup" = "true" ]; then
            logMessage "Overlay $overlay fehlt aktuell; vorhandenes Backup wird beibehalten."
            set_overlay_state_value "$state_file" "original" "present"
            if [ -n "$previous_original_checksum" ]; then
                set_overlay_state_value "$state_file" "original_checksum" "$previous_original_checksum"
            else
                set_overlay_state_value "$state_file" "original_checksum" "unbekannt"
            fi
            if [ -n "$previous_original_recorded_at" ]; then
                set_overlay_state_value "$state_file" "original_recorded_at" "$previous_original_recorded_at"
            else
                set_overlay_state_value "$state_file" "original_recorded_at" "$timestamp"
            fi
            set_overlay_state_value "$state_file" "installed_by_setup" "false"
            set_overlay_state_value "$state_file" "last_action" "backup_retained_missing_overlay"
        elif [ "$overlay_currently_present" = "true" ]; then
            if cp "$overlay_path" "$backup_file"; then
                local checksum="unbekannt"
                if command -v sha256sum >/dev/null 2>&1; then
                    checksum="$(sha256sum "$overlay_path" | awk '{print $1}')"
                fi
                logMessage "Overlay $overlay wurde gesichert (Checksumme: $checksum)."
                set_overlay_state_value "$state_file" "original" "present"
                set_overlay_state_value "$state_file" "original_checksum" "$checksum"
                set_overlay_state_value "$state_file" "original_recorded_at" "$timestamp"
                set_overlay_state_value "$state_file" "installed_by_setup" "false"
                set_overlay_state_value "$state_file" "last_action" "backup_recorded"
            else
                logMessage "Fehler beim Sichern von Overlay $overlay."
                setInstallFailed $EXIT_ERROR "Fehler beim Sichern von Overlay $overlay."
            fi
        else
            logMessage "Overlay $overlay war vor der Installation nicht vorhanden. Markiere Zustand als 'absent'."
            : > "$absent_marker"
            set_overlay_state_value "$state_file" "original" "absent"
            set_overlay_state_value "$state_file" "original_checksum" "nicht_vorhanden"
            set_overlay_state_value "$state_file" "original_recorded_at" "$timestamp"
            set_overlay_state_value "$state_file" "installed_by_setup" "false"
            set_overlay_state_value "$state_file" "last_action" "original_absent_recorded"
        fi

        local setup_checksum_value="sha256_unavailable"
        if [ -f "$source_overlay" ]; then
            if command -v sha256sum >/dev/null 2>&1; then
                setup_checksum_value="$(sha256sum "$source_overlay" | awk '{print $1}')"
            fi
            logMessage "Setup-Overlay-Metadaten für $overlay aktualisiert (Checksumme: $setup_checksum_value)."
        else
            logMessage "Warnung: Quelle für Overlay $overlay konnte bei der Sicherung nicht ermittelt werden."
            setup_checksum_value="quelle_nicht_gefunden"
        fi
        set_overlay_state_value "$state_file" "setup_checksum" "$setup_checksum_value"
        set_overlay_state_value "$state_file" "setup_recorded_at" "$timestamp"
    done
}

# Originaldateien wiederherstellen
restore_originals() {
    logMessage "Stelle Originaldateien wieder her..."
    if restoreFile "$BACKUP_CONFIG_FILE" "$CONFIG_FILE"; then
        configRestorePerformed=true
        logMessage "Originale dbus-adc.conf wurde erfolgreich wiederhergestellt."
    else
        configRestorePerformed=false
        if [ -f "$BACKUP_CONFIG_FILE" ]; then
            logMessage "Warnung: Wiederherstellung der dbus-adc.conf aus der Sicherung ist fehlgeschlagen."
        else
            logMessage "Keine Sicherung der dbus-adc.conf gefunden; Setup-Version bleibt bestehen."
        fi
    fi

    if [ -f "$BACKUP_CONFIG_FILE" ]; then
        configBackupExisted=true
    else
        configBackupExisted=false
    fi

    if restoreFile "$CONFIG_TXT_BACKUP" "$CONFIG_TXT"; then
        configTxtRestorePerformed=true
        logMessage "config.txt wurde erfolgreich aus der Sicherung wiederhergestellt."
    else
        configTxtRestorePerformed=false
        if [ -f "$CONFIG_TXT_BACKUP" ]; then
            logMessage "Warnung: Wiederherstellung der config.txt aus der Sicherung ist fehlgeschlagen."
        else
            logMessage "Keine Sicherung der config.txt gefunden; setze auf manuelle Bereinigung."
        fi
    fi
    if [ -f "$RC_LOCAL_BACKUP" ]; then
        rcLocalBackupAvailable=true
    else
        rcLocalBackupAvailable=false
    fi

    if restoreFile "$RC_LOCAL_BACKUP" "$RC_LOCAL_FILE"; then
        rcLocalRestorePerformed=true
        logMessage "rc.local wurde erfolgreich aus der Sicherung wiederhergestellt."
    else
        rcLocalRestorePerformed=false
        if [ "$rcLocalBackupAvailable" = true ]; then
            logMessage "Warnung: Wiederherstellung der rc.local aus der Sicherung ist fehlgeschlagen."
        else
            logMessage "Keine Sicherung der rc.local gefunden; setze auf gezielte Bereinigung."
        fi
    fi
}

## Hilfsfunktionen für Benutzereingaben
normalize_channel_label() {
    local input="$1"
    local fallback="$2"

    local trimmed
    trimmed="$(printf '%s' "$input" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')"

    if [ -z "$trimmed" ]; then
        trimmed="$fallback"
    fi

    if [ "${#trimmed}" -ge 2 ]; then
        local first_char="${trimmed:0:1}"
        local last_char="${trimmed: -1}"

        if [[ "$first_char" == '"' && "$last_char" == '"' ]]; then
            trimmed="${trimmed:1:-1}"
        elif [[ "$first_char" == $'\'' && "$last_char" == $'\'' ]]; then
            trimmed="${trimmed:1:-1}"
        fi
    fi

    trimmed="$(printf '%s' "$trimmed" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')"

    if [ -z "$trimmed" ]; then
        trimmed="$fallback"
    fi

    printf '%s' "$trimmed"
}

trim_whitespace() {
    local input="$1"

    printf '%s' "$input" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//'
}

escape_for_shell_assignment() {
    local value="$1"

    if [ -z "$value" ]; then
        printf '%s' '""'
        return 0
    fi

    printf '%q' "$value"
}

normalize_device_value() {
    local raw_value="$1"

    if [ -z "$raw_value" ]; then
        printf '%s' ""
        return 0
    fi

    local trimmed_value
    trimmed_value="$(trim_whitespace "$raw_value")"

    if [ -z "$trimmed_value" ]; then
        printf '%s' ""
        return 0
    fi

    local -a tokens=()
    read -r -a tokens <<<"$trimmed_value"

    if [ "${#tokens[@]}" -eq 0 ]; then
        printf '%s' ""
        return 0
    fi

    local first_token="${tokens[0]:-}"

    if [ -z "$first_token" ]; then
        printf '%s' ""
        return 0
    fi

    if [[ "${first_token,,}" = device ]]; then
        if [ "${#tokens[@]}" -ge 2 ]; then
            first_token="${tokens[1]:-}"
        else
            first_token=""
        fi
    fi

    printf '%s' "$first_token"
}

validate_device_value() {
    local raw_value="$1"
    local context="${2:-Device}"
    local log_on_empty="${3:-false}"

    local default_value="$ADC_DEVICE_DEFAULT_VALUE"
    local trimmed_input
    trimmed_input="$(trim_whitespace "${raw_value}")"

    if [ -z "$trimmed_input" ]; then
        if [ "$log_on_empty" = true ]; then
            logMessage "${context}: keine Device-Angabe – verwende ${default_value}."
        fi
        printf '%s' "$default_value"
        return 1
    fi

    local normalized_value
    normalized_value="$(normalize_device_value "$trimmed_input")"

    if [ -n "$normalized_value" ] && [[ "$normalized_value" =~ ^iio:device[0-9]+$ ]]; then
        printf '%s' "$normalized_value"
        return 0
    fi

    if [ -n "$normalized_value" ]; then
        logMessage "${context}: ungültiger Device-Wert \"${normalized_value}\" – verwende ${default_value}."
    else
        logMessage "${context}: Eingabe \"${trimmed_input}\" konnte nicht als Device interpretiert werden – verwende ${default_value}."
    fi

    printf '%s' "$default_value"
    return 1
}

infer_channel_type_from_label() {
    local raw_label="$1"

    local trimmed_label
    trimmed_label="$(trim_whitespace "$raw_label")"

    if [ -z "$trimmed_label" ]; then
        printf 'none'
        return 0
    fi

    local lowered_label="${trimmed_label,,}"

    if [[ "$lowered_label" =~ ^tank([[:digit:][:space:][:punct:]].*)?$ ]]; then
        printf 'tank'
        return 0
    fi

    if [[ "$lowered_label" =~ ^tanksensor([[:digit:][:space:][:punct:]].*)?$ ]]; then
        printf 'tank'
        return 0
    fi

    if [[ "$lowered_label" =~ ^temp([[:digit:][:space:][:punct:]].*)?$ ]]; then
        printf 'temp'
        return 0
    fi

    if [[ "$lowered_label" =~ ^temperatur([[:digit:][:space:][:punct:]].*)?$ ]]; then
        printf 'temp'
        return 0
    fi

    if [[ "$lowered_label" =~ ^temperature([[:digit:][:space:][:punct:]].*)?$ ]]; then
        printf 'temp'
        return 0
    fi

    if [[ "$lowered_label" =~ ^tempsensor([[:digit:][:space:][:punct:]].*)?$ ]]; then
        printf 'temp'
        return 0
    fi

    printf '%s' "$lowered_label"
}

canonicalize_sensor_type() {
    local raw_value="$1"
    local trimmed_value
    trimmed_value="$(trim_whitespace "$raw_value")"

    local lowered_value="${trimmed_value,,}"
    local compact_value="${lowered_value//[[:space:]-_]/}"

    local candidate=""
    for candidate in "$lowered_value" "$compact_value"; do
        case "$candidate" in
            ""|none|leer|aus|ausgeschaltet|disabled|off|kein|keine|keiner|deaktiviert|"nicht belegt"|nichtbelegt|0)
                printf 'none'
                return 0
                ;;
            tank|t|tank-sensor|tanksensor|fuel|diesel|wasser|water|level|tankgeber)
                printf 'tank'
                return 0
                ;;
            temp|temperatur|temperature|tempsensor|temp-sensor|temperature-sensor|temperaturesensor|temperatursensor|temperatur-sensor|'temperature sensor'|'temperatur sensor'|heat)
                printf 'temp'
                return 0
                ;;
        esac
    done

    printf 'invalid'
}

channel_label_fallback() {
    local channel="$1"
    local channel_type="$2"
    local channel_index=$((channel + 1))

    local normalized_type="${channel_type,,}"

    case "$normalized_type" in
        tank)
            printf 'tank%s' "$channel_index"
            ;;
        temp)
            printf 'temperatur%s' "$channel_index"
            ;;
        none|""|invalid)
            printf 'sensor_%s' "$channel_index"
            ;;
        *)
            local sanitized_type
            sanitized_type="$(printf '%s' "$normalized_type" | tr -cd '[:alnum:]')"
            if [ -z "$sanitized_type" ]; then
                sanitized_type="sensor"
            fi
            printf '%s%s' "$sanitized_type" "$channel_index"
            ;;
    esac
}

validate_channel_types() {
    local -n _types="$1"
    local -n _invalid="$2"

    _invalid=()

    local total_channels="${TOTAL_ADC_CHANNELS:-0}"
    local index
    for (( index=0; index<total_channels; index++ )); do
        local raw_type=""
        if [ -n "${_types[index]+set}" ]; then
            raw_type="${_types[index]}"
        fi

        local canonical
        canonical="$(canonicalize_sensor_type "$raw_type")"

        case "$canonical" in
            tank|temp)
                _types[index]="$canonical"
                ;;
            none|"")
                _types[index]="none"
                ;;
            invalid)
                local display_index=$((index + 1))
                local trimmed_raw
                trimmed_raw="$(trim_whitespace "${raw_type}")"
                if [ -z "$trimmed_raw" ]; then
                    trimmed_raw="?"
                fi
                _invalid+=("${display_index}:${trimmed_raw}")
                _types[index]="invalid"
                ;;
            *)
                local display_index=$((index + 1))
                local trimmed_raw
                trimmed_raw="$(trim_whitespace "${raw_type}")"
                if [ -z "$trimmed_raw" ]; then
                    trimmed_raw="?"
                fi
                _invalid+=("${display_index}:${trimmed_raw}")
                _types[index]="invalid"
                ;;
        esac
    done

    if [ "${#_invalid[@]}" -gt 0 ]; then
        return 1
    fi

    return 0
}

load_default_adc_defaults() {
    local -n _out_vref="$1"
    local -n _out_scale="$2"
    local -n _out_types="$3"
    local -n _out_labels="$4"
    # Erwartet als fünftes Argument den Variablennamen für die Device-Ausgabe (Namens-Referenz).
    local -n _out_device="$5"

    local template_file="${SOURCE_FILE_DIR}/configs/dbus-adc.conf"
    local template_loaded=false
    local default_vref=""
    local default_scale=""
    local template_device=""
    local -a parsed_types=()
    local -a parsed_labels=()
    local -a fallback_messages=()
    local channels_fallback=false

    if parse_default_adc_configuration "$template_file" default_vref default_scale parsed_types parsed_labels template_device; then
        template_loaded=true
    else
        logMessage "Konfigurationsvorlage '${template_file}' konnte nicht geladen werden. Verwende Fallback-Werte."
    fi

    if [ -z "$template_device" ]; then
        template_device="$ADC_DEVICE_DEFAULT_VALUE"
        fallback_messages+=("Device (${ADC_DEVICE_DEFAULT_VALUE})")
    fi

    if [ -z "$default_vref" ]; then
        default_vref="$DEFAULT_VREF_FALLBACK"
        fallback_messages+=("Vref (${DEFAULT_VREF_FALLBACK})")
    fi

    if [ -z "$default_scale" ]; then
        default_scale="$DEFAULT_SCALE_FALLBACK"
        fallback_messages+=("Scale (${DEFAULT_SCALE_FALLBACK})")
    fi

    local channel
    for (( channel=0; channel<TOTAL_ADC_CHANNELS; channel++ )); do
        local type_value=""
        local label_value=""
        local label_from_template=false

        if [ -n "${parsed_types[channel]+set}" ] && [ -n "${parsed_types[channel]}" ]; then
            type_value="${parsed_types[channel]}"
        fi

        if [ -z "$type_value" ]; then
            if [ -n "${DEFAULT_CHANNEL_TYPES_FALLBACK[channel]+set}" ]; then
                type_value="${DEFAULT_CHANNEL_TYPES_FALLBACK[channel]}"
            else
                type_value=""
            fi
            channels_fallback=true
        fi

        if [ -n "${parsed_labels[channel]+set}" ]; then
            label_value="${parsed_labels[channel]}"
            if [ -n "$label_value" ]; then
                label_from_template=true
            fi
        fi

        if [ -z "$label_value" ]; then
            if [ -n "$type_value" ]; then
                label_value="$(channel_label_fallback "$channel" "$type_value")"
            elif [ -n "${DEFAULT_CHANNEL_LABELS_FALLBACK[channel]+set}" ]; then
                label_value="${DEFAULT_CHANNEL_LABELS_FALLBACK[channel]}"
            else
                label_value="$(channel_label_fallback "$channel" "none")"
            fi
            channels_fallback=true
        elif [ "$label_from_template" = false ]; then
            channels_fallback=true
        fi

        _out_types[channel]="$type_value"
        _out_labels[channel]="$label_value"
    done

    if [ "$channels_fallback" = true ]; then
        fallback_messages+=("Kanäle (Fallback-Vorbelegung)")
    fi

    if [ "${#fallback_messages[@]}" -gt 0 ]; then
        if [ "$template_loaded" = true ]; then
            logMessage "Unvollständige Angaben in '${template_file}'. Fallback-Werte verwendet für: ${fallback_messages[*]}."
        else
            logMessage "Fallback-Werte verwendet für: ${fallback_messages[*]}."
        fi
    fi

    _out_vref="$default_vref"
    _out_scale="$default_scale"
    _out_device="$template_device"
}

is_truthy() {
    local value="$1"
    case "${value,,}" in
        1|true|yes|y|on)
            return 0
            ;;
    esac
    return 1
}

sanitize_numeric_value() {
    local raw_value="$1"
    local min_value="$2"
    local max_value="$3"
    local fallback_value="$4"
    local value_label="$5"
    local numeric_mode="${6:-float}"

    if [ -z "$raw_value" ]; then
        printf '%s\n' "$raw_value"
        return 0
    fi

    local sanitized_value
    sanitized_value="$(trim_whitespace "$raw_value")"

    local int_pattern='^-?[0-9]+$'
    local float_pattern='^[-+]?[0-9]+([.][0-9]+)?$'

    if [ -z "$min_value" ] || [ -z "$max_value" ]; then
        printf '%s\n' "$sanitized_value"
        return 0
    fi

    local in_range=true
    local rejection_reason=""

    if [ "$numeric_mode" = "int" ]; then
        if ! [[ "$sanitized_value" =~ $int_pattern ]]; then
            in_range=false
            rejection_reason="pattern"
        elif [ "$sanitized_value" -lt "$min_value" ] || [ "$sanitized_value" -gt "$max_value" ]; then
            in_range=false
            rejection_reason="range"
        fi
    else
        if [[ "$sanitized_value" == *","* ]]; then
            in_range=false
            rejection_reason="decimal_comma"
        elif ! [[ "$sanitized_value" =~ $float_pattern ]]; then
            in_range=false
            rejection_reason="pattern"
        elif ! awk -v v="$sanitized_value" -v min="$min_value" -v max="$max_value" 'BEGIN { if (v < min || v > max) exit 1; exit 0 }'; then
            in_range=false
            rejection_reason="range"
        fi
    fi

    if [ "$in_range" = true ]; then
        printf '%s\n' "$sanitized_value"
        return 0
    fi

    local fallback_candidate="$fallback_value"
    if [ -n "$fallback_candidate" ]; then
        fallback_candidate="$(trim_whitespace "$fallback_candidate")"
    fi

    if [ -z "$fallback_candidate" ]; then
        fallback_candidate="$min_value"
    else
        local fallback_valid=true
        if [ "$numeric_mode" = "int" ]; then
            if ! [[ "$fallback_candidate" =~ $int_pattern ]]; then
                fallback_valid=false
            elif [ "$fallback_candidate" -lt "$min_value" ] || [ "$fallback_candidate" -gt "$max_value" ]; then
                fallback_valid=false
            fi
        else
            if [[ "$fallback_candidate" == *","* ]]; then
                fallback_valid=false
            elif ! [[ "$fallback_candidate" =~ $float_pattern ]]; then
                fallback_valid=false
            elif ! awk -v v="$fallback_candidate" -v min="$min_value" -v max="$max_value" 'BEGIN { if (v < min || v > max) exit 1; exit 0 }'; then
                fallback_valid=false
            fi
        fi

        if [ "$fallback_valid" = false ]; then
            fallback_candidate="$min_value"
        fi
    fi

    local rejection_message=""
    case "$rejection_reason" in
        decimal_comma)
            rejection_message="${value_label:-Wert} ${sanitized_value} verwendet ein Dezimalkomma – verwende ${fallback_candidate}."
            ;;
        pattern)
            rejection_message="${value_label:-Wert} ${sanitized_value} hat ein ungültiges Zahlenformat – verwende ${fallback_candidate}."
            ;;
        range)
            rejection_message="${value_label:-Wert} ${sanitized_value} liegt außerhalb des zulässigen Bereichs (${min_value} – ${max_value}). Verwende ${fallback_candidate}."
            ;;
        *)
            rejection_message="${value_label:-Wert} ${sanitized_value} ist ungültig – verwende ${fallback_candidate}."
            ;;
    esac

    logMessage "$rejection_message"

    printf '%s\n' "$fallback_candidate"
}

## Benutzerinteraktion für die dbus-adc Konfiguration
prompt_numeric_value() {
    local prompt_text="$1"
    local default_value="$2"
    local validation_regex="$3"
    local error_message="$4"
    local env_var_name="${5:-}"
    local min_value="${6:-}"
    local max_value="${7:-}"
    local fallback_value="${8:-}"
    local value_label="${9:-$prompt_text}"
    local numeric_mode="${10:-float}"
    local value=""

    if [ -n "$default_value" ]; then
        default_value="$(trim_whitespace "$default_value")"
    fi

    if [ "$nonInteractiveMode" = true ]; then
        local candidate="$default_value"
        local source="Standardwert"
        if [ -n "$env_var_name" ]; then
            local env_value="${!env_var_name:-}"
            if [ -n "$env_value" ]; then
                local trimmed_env_value
                trimmed_env_value="$(trim_whitespace "$env_value")"
                if [ -n "$trimmed_env_value" ]; then
                    candidate="$trimmed_env_value"
                    source="Umgebungsvariable ${env_var_name}"
                fi
            fi
        fi

        if [ -n "$candidate" ]; then
            candidate="$(trim_whitespace "$candidate")"
        fi

        if [[ "$candidate" =~ $validation_regex ]]; then
            local sanitized_candidate
            sanitized_candidate="$(sanitize_numeric_value "$candidate" "$min_value" "$max_value" "$fallback_value" "$value_label" "$numeric_mode")"
            logMessage "Nicht-interaktiv: verwende ${source} (${candidate}) für ${prompt_text}."
            echo "$sanitized_candidate"
            return 0
        fi

        logMessage "Nicht-interaktiv: ${source} '${candidate}' ist ungültig für ${prompt_text}. Verwende Fallback '${default_value}'."

        if [ -n "$default_value" ] && [[ "$default_value" =~ $validation_regex ]]; then
            echo "$default_value"
            return 0
        fi

        local fallback_candidate=""
        case "$env_var_name" in
            EXPANDERPI_VREF)
                fallback_candidate="$DEFAULT_VREF_FALLBACK"
                ;;
            EXPANDERPI_SCALE)
                fallback_candidate="$DEFAULT_SCALE_FALLBACK"
                ;;
        esac

        if [ -n "$fallback_candidate" ]; then
            fallback_candidate="$(trim_whitespace "$fallback_candidate")"
        fi

        if [ -n "$fallback_candidate" ] && [[ "$fallback_candidate" =~ $validation_regex ]]; then
            local sanitized_fallback
            sanitized_fallback="$(sanitize_numeric_value "$fallback_candidate" "$min_value" "$max_value" "$fallback_value" "$value_label" "$numeric_mode")"
            logMessage "Nicht-interaktiv: setze ${prompt_text} auf Skriptstandard ${fallback_candidate}."
            echo "$sanitized_fallback"
            return 0
        fi

        logMessage "Nicht-interaktiv: Konnte keinen gültigen Wert für ${prompt_text} bestimmen. Setze auf '0'."
        echo "0"
        return 0
    fi

    while true; do
        if [ -n "$default_value" ]; then
            read -rp "${prompt_text} [${default_value}]: " value
        else
            read -rp "${prompt_text}: " value
        fi

        value="$(trim_whitespace "$value")"

        if [ -z "$value" ]; then
            value="$default_value"
        fi

        if [ -z "$value" ]; then
            logMessage "$error_message"
            continue
        fi

        if [[ "$value" =~ $validation_regex ]]; then
            local sanitized_value
            sanitized_value="$(sanitize_numeric_value "$value" "$min_value" "$max_value" "$fallback_value" "$value_label" "$numeric_mode")"
            if declare -F yesNoPrompt >/dev/null 2>&1; then
                if yesNoPrompt "Wert '${sanitized_value}' übernehmen (y/n)? "; then
                    echo "$sanitized_value"
                    return 0
                else
                    logMessage "Eingabe verworfen. Bitte erneut eingeben."
                    continue
                fi
            else
                echo "$sanitized_value"
                return 0
            fi
        fi

        logMessage "$error_message"
    done
}

prompt_sensor_label() {
    local channel="$1"
    local default_value="$2"
    local require_non_empty="${3:-false}"
    local channel_display=$((channel + 1))
    local prompt_text="Sensorbezeichnung für Kanal ${channel_display}"
    local input=""

    if [ "$nonInteractiveMode" = true ]; then
        local env_var_name="EXPANDERPI_CHANNEL_${channel}_LABEL"
        local candidate="${!env_var_name:-$default_value}"
        local fallback="sensor_${channel_display}"

        if [ "$require_non_empty" = false ] && [ -z "$candidate" ]; then
            logMessage "Nicht-interaktiv: Kanal ${channel_display} bleibt ohne Sensor."
            echo ""
            return 0
        fi

        if [ -z "$candidate" ]; then
            candidate="$fallback"
            logMessage "Nicht-interaktiv: verwende Platzhalter '${candidate}' für Kanal ${channel_display}."
        else
            logMessage "Nicht-interaktiv: verwende Umgebungswert '${candidate}' für Kanal ${channel_display}."
        fi

        local normalized
        normalized="$(normalize_channel_label "$candidate" "$fallback")"
        echo "$normalized"
        return 0
    fi

    while true; do
        if [ -n "$default_value" ]; then
            read -rp "${prompt_text} (${default_value}): " input
        else
            read -rp "${prompt_text}: " input
        fi

        if [ -z "$input" ]; then
            input="$default_value"
        fi

        local trimmed_input
        trimmed_input="$(printf '%s' "$input" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')"
        local lowered_input
        lowered_input="${trimmed_input,,}"

        if [ -z "$trimmed_input" ] || [[ "$lowered_input" =~ ^(-|none|leer|kein|keine|aus)$ ]]; then
            if [ "$require_non_empty" = "true" ]; then
                logMessage "Bitte eine Sensorbezeichnung für Kanal ${channel_display} angeben."
                continue
            fi

            if declare -F yesNoPrompt >/dev/null 2>&1; then
                if yesNoPrompt "Kanal ${channel_display} ohne Sensor belassen (y/n)? "; then
                    echo ""
                    return 0
                else
                    logMessage "Bitte Sensorbezeichnung erneut angeben."
                    continue
                fi
            else
                echo ""
                return 0
            fi
        fi

        local fallback_label="$default_value"
        if [ -z "$fallback_label" ]; then
            fallback_label="$(channel_label_fallback "$channel" "none")"
        fi

        local normalized_input
        normalized_input="$(normalize_channel_label "$trimmed_input" "$fallback_label")"

        if [ -z "$normalized_input" ]; then
            logMessage "Bitte eine Sensorbezeichnung für Kanal ${channel_display} angeben."
            continue
        fi

        if declare -F yesNoPrompt >/dev/null 2>&1; then
            if yesNoPrompt "Sensor '${normalized_input}' für Kanal ${channel_display} übernehmen (y/n)? "; then
                echo "$normalized_input"
                return 0
            else
                logMessage "Eingabe verworfen. Bitte erneut angeben."
                continue
            fi
        else
            echo "$normalized_input"
            return 0
        fi
    done
}

prompt_channel_assignment() {
    local channel="$1"
    local default_type="$2"
    local default_label="$3"
    local channel_display=$((channel + 1))

    if [ "$nonInteractiveMode" = true ]; then
        local env_var_base="EXPANDERPI_CHANNEL_${channel}"
        local env_value="${!env_var_base:-}"
        local env_type_var="${env_var_base}_TYPE"
        local env_label_var="${env_var_base}_LABEL"
        local env_type="${!env_type_var:-}"
        local env_label="${!env_label_var:-}"

        local raw_type=""
        local raw_label=""

        if [ -n "$env_value" ]; then
            if [[ "$env_value" =~ ^([^|:;,]*)([|:;,])(.*)$ ]]; then
                raw_type="${BASH_REMATCH[1]}"
                raw_label="${BASH_REMATCH[3]}"
            else
                raw_type="$env_value"
            fi

            raw_type="$(trim_whitespace "$raw_type")"
        fi

        if [ -z "$raw_type" ] && [ -n "$env_type" ]; then
            raw_type="$(trim_whitespace "$env_type")"
        fi

        if [ -z "$raw_label" ] && [ -n "$env_label" ]; then
            raw_label="$env_label"
        fi

        if [ -z "$raw_type" ]; then
            raw_type="$(trim_whitespace "$default_type")"
        fi

        local canonical_type
        canonical_type="$(canonicalize_sensor_type "$raw_type")"

        local log_source="Standardwerte"
        if [ -n "$env_value" ] || [ -n "$env_type" ]; then
            log_source="Umgebungsvariablen"
        fi

        case "$canonical_type" in
            none)
                logMessage "Nicht-interaktiv: ${log_source} führen dazu, dass Kanal ${channel_display} deaktiviert bleibt."
                printf 'none|\n'
                return 0
                ;;
            tank|temp)
                local fallback_label
                fallback_label="$(channel_label_fallback "$channel" "$canonical_type")"
                local normalized_label=""
                if [ -n "$raw_label" ]; then
                    normalized_label="$(normalize_channel_label "$raw_label" "$fallback_label")"
                elif [ -n "$default_label" ]; then
                    normalized_label="$(normalize_channel_label "$default_label" "$fallback_label")"
                else
                    normalized_label="$fallback_label"
                fi
                logMessage "Nicht-interaktiv: ${log_source} setzen Kanal ${channel_display} auf ${canonical_type}-Sensor (${normalized_label})."
                printf '%s|%s\n' "$canonical_type" "$normalized_label"
                return 0
                ;;
            invalid)
                local raw_display
                raw_display="$(trim_whitespace "$raw_type")"
                if [ -z "$raw_display" ]; then
                    raw_display="?"
                fi
                logMessage "Nicht-interaktiv: ${log_source} liefern den nicht unterstützten Sensortyp '${raw_display}' für Kanal ${channel_display}."
                printf 'invalid|\n'
                return 0
                ;;
        esac
    fi

    local normalized_default_type
    normalized_default_type="$(canonicalize_sensor_type "$default_type")"
    if [ "$normalized_default_type" = "invalid" ]; then
        logMessage "Kanal ${channel_display}: gespeicherter Sensortyp '${default_type}' wird nicht unterstützt und wird auf 'none' zurückgesetzt."
        normalized_default_type="none"
    fi

    local prompt_suffix=""
    case "$normalized_default_type" in
        tank)
            prompt_suffix="tank"
            ;;
        temp)
            prompt_suffix="temp"
            ;;
        none)
            prompt_suffix="leer"
            ;;
    esac

    while true; do
        local reply=""
        if [ -n "$prompt_suffix" ]; then
            read -rp "Sensortyp für Kanal ${channel_display} [${prompt_suffix}]: " reply
        else
            read -rp "Sensortyp für Kanal ${channel_display}: " reply
        fi

        if [ -z "$reply" ]; then
            reply="$normalized_default_type"
        fi

        reply="$(printf '%s' "$reply" | tr '[:upper:]' '[:lower:]')"
        local reply_type
        reply_type="$(canonicalize_sensor_type "$reply")"

        case "$reply_type" in
            none)
                if declare -F yesNoPrompt >/dev/null 2>&1; then
                    if yesNoPrompt "Kanal ${channel_display} ohne Sensor übernehmen (y/n)? "; then
                        printf 'none|\n'
                        return 0
                    else
                        logMessage "Bitte Auswahl erneut treffen."
                        continue
                    fi
                else
                    printf 'none|\n'
                    return 0
                fi
                ;;
            tank)
                if declare -F yesNoPrompt >/dev/null 2>&1; then
                    if ! yesNoPrompt "Kanal ${channel_display} als Tank-Sensor übernehmen (y/n)? "; then
                        logMessage "Bitte Auswahl erneut treffen."
                        continue
                    fi
                fi
                local tank_label="$default_label"
                if [ -z "$tank_label" ]; then
                    tank_label="$(channel_label_fallback "$channel" "tank")"
                fi
                local normalized_tank_label
                normalized_tank_label="$(prompt_sensor_label "$channel" "$tank_label" true)"
                if [ -z "$normalized_tank_label" ]; then
                    logMessage "Sensorbezeichnung für Tank-Sensor darf nicht leer sein."
                    continue
                fi
                default_label="$normalized_tank_label"
                printf 'tank|%s\n' "$normalized_tank_label"
                return 0
                ;;
            temp)
                if declare -F yesNoPrompt >/dev/null 2>&1; then
                    if ! yesNoPrompt "Kanal ${channel_display} als Temperatur-Sensor übernehmen (y/n)? "; then
                        logMessage "Bitte Auswahl erneut treffen."
                        continue
                    fi
                fi
                local temp_label="$default_label"
                if [ -z "$temp_label" ]; then
                    temp_label="$(channel_label_fallback "$channel" "temp")"
                fi
                local normalized_temp_label
                normalized_temp_label="$(prompt_sensor_label "$channel" "$temp_label" true)"
                if [ -z "$normalized_temp_label" ]; then
                    logMessage "Sensorbezeichnung für Temperatur-Sensor darf nicht leer sein."
                    continue
                fi
                default_label="$normalized_temp_label"
                printf 'temp|%s\n' "$normalized_temp_label"
                return 0
                ;;
            invalid)
                logMessage "Ungültige Auswahl für Kanal ${channel_display}. Gültig sind 'tank', 'temp' oder 'none'."
                continue
                ;;
            *)
                logMessage "Ungültige Auswahl für Kanal ${channel_display}. Gültig sind 'tank', 'temp' oder 'none'."
                continue
                ;;
        esac
    done
}

format_label_for_dbus_config() {
    local label="$1"

    local escaped=${label//\/\\}
    local dq='"'
    local dq_escape='\"'
    escaped=${escaped//"$dq"/$dq_escape}

    local needs_quotes=false
    local without_quotes=${label//"$dq"/}
    if [ "$without_quotes" != "$label" ]; then
        needs_quotes=true
    elif [[ "$label" == *[[:space:]]* || "$label" == *#* ]]; then
        needs_quotes=true
    fi

    if [ "$needs_quotes" = true ]; then
        printf '%s%s%s' "$dq" "$escaped" "$dq"
    else
        printf '%s' "$escaped"
    fi
}

## Konfigurationsdateien installieren und deinstallieren
# Konfigurationsdateien installieren
install_config() {
    local invocation_mode="${1:-install}"
    local check_mode=false

    if [ "$invocation_mode" = "precheck" ]; then
        check_mode=true
    fi

    if is_check_mode; then
        check_mode=true
    fi

    logMessage "Installiere dbus-adc.conf..."

    if [ "$check_mode" != true ]; then
        mkdir -p "$ROOT_PATH"
    fi

    local default_vref=""
    local default_scale=""
    local default_device=""
    local -a default_channel_types=()
    local -a default_channel_labels=()

    load_default_adc_defaults default_vref default_scale default_channel_types default_channel_labels default_device

    local -a channel_types
    local -a channel_labels
    local -a saved_channel_types
    local -a saved_channel_labels
    local channel

    for (( channel=0; channel<TOTAL_ADC_CHANNELS; channel++ )); do
        channel_types[channel]="${default_channel_types[channel]}"
        channel_labels[channel]="${default_channel_labels[channel]}"
        saved_channel_types[channel]=""
        saved_channel_labels[channel]=""
    done

    local saved_vref=""
    local saved_scale=""
    local saved_device=""
    if [ -f "$USER_CONFIG_FILE" ]; then
        # shellcheck source=/dev/null
        source "$USER_CONFIG_FILE"
        saved_vref="${USER_VREF:-}"
        saved_scale="${USER_SCALE:-}"
        if [ -n "${USER_DEVICE+x}" ]; then
            local validated_saved_device=""
            if validated_saved_device="$(validate_device_value "${USER_DEVICE}" "Benutzerkonfiguration (USER_DEVICE)" true)"; then
                saved_device="$validated_saved_device"
            else
                saved_device="$validated_saved_device"
            fi
        fi
        for (( channel=0; channel<TOTAL_ADC_CHANNELS; channel++ )); do
            local label_var="USER_CHANNEL_${channel}"
            local type_var="USER_CHANNEL_${channel}_TYPE"
            local saved_label=""
            local saved_type=""

            if [[ -v ${label_var} ]]; then
                saved_label="${!label_var}"
            fi

            if [[ -v ${type_var} ]]; then
                saved_type="${!type_var}"
            fi

            if [ -z "$saved_type" ]; then
                saved_type="$(infer_channel_type_from_label "$saved_label")"
            fi

            saved_type="$(canonicalize_sensor_type "$saved_type")"

            saved_channel_labels[channel]="$saved_label"
            saved_channel_types[channel]="$saved_type"
        done
    fi

    local previous_non_interactive_mode="$nonInteractiveMode"
    local gui_values_loaded=false

    if load_gui_configuration; then
        gui_values_loaded=true
        logMessage "Übernehme Werte aus der SetupHelper-Oberfläche als Voreinstellungen."
        if [ "$previous_non_interactive_mode" = true ]; then
            nonInteractiveMode=true
            logMessage "SetupHelper fordert einen nicht-interaktiven Lauf an; nicht-interaktiver Modus bleibt aktiv."
        else
            logMessage "Interaktive Ausführung: Verwende SetupHelper-Werte als Standardvorgaben."
        fi
    else
        logMessage "SetupHelper lieferte keine GUI-Voreinstellungen. Prüfe Umgebungsvariablen EXPANDERPI_* und vorhandene Benutzerwerte."
    fi

    if [ -n "${EXPANDERPI_VREF:-}" ]; then
        saved_vref="${EXPANDERPI_VREF}";
        if [ "$gui_values_loaded" = false ]; then
            logMessage "Übernehme Vref aus Umgebungsvariable EXPANDERPI_VREF (${saved_vref})."
        fi
    fi
    if [ -n "${EXPANDERPI_SCALE:-}" ]; then
        saved_scale="${EXPANDERPI_SCALE}";
        if [ "$gui_values_loaded" = false ]; then
            logMessage "Übernehme Scale aus Umgebungsvariable EXPANDERPI_SCALE (${saved_scale})."
        fi
    fi
    if [ -n "${EXPANDERPI_DEVICE+x}" ]; then
        local env_device=""
        env_device="$(validate_device_value "${EXPANDERPI_DEVICE}" "Umgebungsvariable EXPANDERPI_DEVICE" true)"
        local env_device_status=$?
        saved_device="$env_device"
        if [ "$gui_values_loaded" = false ] && [ $env_device_status -eq 0 ]; then
            logMessage "Übernehme Device aus Umgebungsvariable EXPANDERPI_DEVICE (${saved_device})."
        fi
    fi

    for (( channel=0; channel<TOTAL_ADC_CHANNELS; channel++ )); do
        local channel_display=$((channel + 1))
        local gui_type_var="EXPANDERPI_CHANNEL_${channel}_TYPE"
        local gui_label_var="EXPANDERPI_CHANNEL_${channel}_LABEL"
        local gui_type="${!gui_type_var:-}"
        local gui_label="${!gui_label_var:-}"

        if [ -n "$gui_type" ]; then
            saved_channel_types[channel]="$(canonicalize_sensor_type "$gui_type")"
        fi

        if [ -n "$gui_type" ] || [ -n "$gui_label" ]; then
            local current_type="${saved_channel_types[channel]}"
            if [ "${current_type,,}" = "none" ]; then
                saved_channel_labels[channel]=""
            else
                local label_fallback
                label_fallback="$(channel_label_fallback "$channel" "$current_type")"
                saved_channel_labels[channel]="$(normalize_channel_label "$gui_label" "$label_fallback")"
            fi
            if [ "$gui_values_loaded" = false ]; then
                logMessage "Übernehme Kanal ${channel_display} aus Umgebungsvariablen (${saved_channel_labels[channel]:-leer}/${saved_channel_types[channel]:-none})."
            fi
        fi
    done

    local use_saved=false
    if [ -n "$saved_vref" ] || [ -n "$saved_scale" ]; then
        local summary=""
        for (( channel=0; channel<TOTAL_ADC_CHANNELS; channel++ )); do
            local channel_display=$((channel + 1))
            local type_value="${saved_channel_types[channel]}"
            local label_value="${saved_channel_labels[channel]}"
            if [ -n "$label_value" ]; then
                summary+="Kanal ${channel_display}: ${label_value} (${type_value}), "
            else
                summary+="Kanal ${channel_display}: leer, "
            fi
        done
        summary="${summary%, }"

        logMessage "Gefundene gespeicherte Werte: Device=${saved_device:-nicht gesetzt}, Vref=${saved_vref:-nicht gesetzt}, Scale=${saved_scale:-nicht gesetzt}."
        logMessage "Gespeicherte Kanalzuordnung: ${summary}"
        if [ "$nonInteractiveMode" = true ]; then
            local use_saved_env="${EXPANDERPI_USE_SAVED:-}"
            if [ -n "$use_saved_env" ]; then
                if is_truthy "$use_saved_env"; then
                    use_saved=true
                    logMessage "Nicht-interaktiv: verwende gespeicherte Konfiguration gemäß EXPANDERPI_USE_SAVED=${use_saved_env}."
                else
                    use_saved=false
                    logMessage "Nicht-interaktiv: verwerfe gespeicherte Konfiguration gemäß EXPANDERPI_USE_SAVED=${use_saved_env}."
                fi
            else
                if [ "$gui_values_loaded" = true ]; then
                    use_saved=true
                    logMessage "Nicht-interaktiv: verwende automatisch die aus der SetupHelper-Oberfläche geladenen Werte."
                else
                    use_saved=false
                    logMessage "Nicht-interaktiv: keine GUI-Daten verfügbar – verwende aktuelle Umgebungswerte bzw. Standardvorgaben."
                fi
            fi
        else
            if declare -F yesNoPrompt >/dev/null 2>&1; then
                if yesNoPrompt "Gespeicherte Konfiguration wiederverwenden (y/n)? "; then
                    use_saved=true
                fi
            else
                local response=""
                while true; do
                    read -rp "Gespeicherte Konfiguration wiederverwenden (y/n)? " response
                    case "$response" in
                        [yY]*)
                            use_saved=true
                            break
                            ;;
                        [nN]*)
                            use_saved=false
                            break
                            ;;
                    esac
                done
            fi
        fi
    fi

    local vref_value=""
    local scale_value=""
    local device_value=""

    if $use_saved; then
        vref_value="${saved_vref:-$default_vref}"
        scale_value="${saved_scale:-$default_scale}"
        device_value="${saved_device:-$default_device}"
        for (( channel=0; channel<TOTAL_ADC_CHANNELS; channel++ )); do
            local saved_label="${saved_channel_labels[channel]}"
            local saved_type
            saved_type="$(canonicalize_sensor_type "${saved_channel_types[channel]}")"
            saved_channel_types[channel]="$saved_type"
            channel_types[channel]="$saved_type"

            if [ "${saved_type,,}" != "none" ]; then
                local label_fallback
                label_fallback="$(channel_label_fallback "$channel" "$saved_type")"
                local normalized_label
                normalized_label="$(normalize_channel_label "$saved_label" "$label_fallback")"
                channel_labels[channel]="$normalized_label"
                saved_channel_labels[channel]="$normalized_label"
            else
                channel_labels[channel]=""
                saved_channel_labels[channel]=""
            fi
        done
        logMessage "Gespeicherte Konfiguration wird erneut angewendet."
    else
        local prompt_vref_default="${saved_vref:-$default_vref}"
        local prompt_scale_default="${saved_scale:-$default_scale}"
        device_value="${saved_device:-$default_device}"
        vref_value="$(prompt_numeric_value "Referenzspannung (Vref)" "$prompt_vref_default" '^[0-9]+([.][0-9]+)?$' "Bitte eine gültige Zahl für Vref eingeben." "EXPANDERPI_VREF" "$ADC_VREF_MIN" "$ADC_VREF_MAX" "$DEFAULT_VREF_FALLBACK" "Vref" "float")"
        scale_value="$(prompt_numeric_value "Skalierungsfaktor (Scale)" "$prompt_scale_default" '^[0-9]+$' "Bitte eine ganze Zahl für den Skalierungsfaktor angeben." "EXPANDERPI_SCALE" "$ADC_SCALE_MIN" "$ADC_SCALE_MAX" "$DEFAULT_SCALE_FALLBACK" "Scale" "int")"

        for (( channel=0; channel<TOTAL_ADC_CHANNELS; channel++ )); do
            local default_type="${saved_channel_types[channel]}"
            local default_label="${saved_channel_labels[channel]}"

            if [ -z "$default_type" ]; then
                default_type="${channel_types[channel]}"
            fi

            default_type="$(canonicalize_sensor_type "$default_type")"
            saved_channel_types[channel]="$default_type"

            if [ "$default_type" = "none" ]; then
                default_label=""
            elif [ -z "$default_label" ]; then
                default_label="${channel_labels[channel]}"
            fi

            local response
            response="$(prompt_channel_assignment "$channel" "$default_type" "$default_label")"
            local selected_type="${response%%|*}"
            local selected_label="${response#*|}"

            channel_types[channel]="${selected_type:-none}"
            channel_labels[channel]="$selected_label"
        done
    fi

    vref_value="$(sanitize_numeric_value "$vref_value" "$ADC_VREF_MIN" "$ADC_VREF_MAX" "$DEFAULT_VREF_FALLBACK" "Vref" "float")"
    scale_value="$(sanitize_numeric_value "$scale_value" "$ADC_SCALE_MIN" "$ADC_SCALE_MAX" "$DEFAULT_SCALE_FALLBACK" "Scale" "int")"

    local validated_device_value=""
    validated_device_value="$(validate_device_value "${device_value:-$default_device}" "Ausgewählter Device-Wert" true)"
    device_value="$validated_device_value"

    local device_line="device ${device_value}"

    local mapping_summary=""
    for (( channel=0; channel<TOTAL_ADC_CHANNELS; channel++ )); do
        local channel_display=$((channel + 1))
        if [ -n "${channel_labels[channel]}" ]; then
            mapping_summary+="Kanal ${channel_display}: ${channel_labels[channel]} (${channel_types[channel]}), "
        else
            mapping_summary+="Kanal ${channel_display}: leer, "
        fi
    done
    mapping_summary="${mapping_summary%, }"

    logMessage "Verwende Device=${device_value}, Vref=${vref_value}, Scale=${scale_value}."
    logMessage "Kanalzuordnung: ${mapping_summary}"

    local -a invalid_channel_types=()
    if ! validate_channel_types channel_types invalid_channel_types; then
        local invalid_summary=""
        local invalid_entry
        for invalid_entry in "${invalid_channel_types[@]}"; do
            local channel_number="${invalid_entry%%:*}"
            local channel_value="${invalid_entry#*:}"
            if [ -n "$invalid_summary" ]; then
                invalid_summary+="; "
            fi
            invalid_summary+="Kanal ${channel_number} (${channel_value})"
        done
        if [ -z "$invalid_summary" ]; then
            invalid_summary="Unbekannte Sensortypen"
        fi
        logMessage "Fehler: Nicht unterstützte Sensortypen gefunden – ${invalid_summary}."
        setInstallFailed $EXIT_ERROR "Nicht unterstützte Sensortypen erkannt (${invalid_summary})."
        return 1
    fi

    local -a unsupported_channels=()
    local -a config_lines=()

    config_lines+=("${device_line}")
    config_lines+=("vref ${vref_value}")
    config_lines+=("scale ${scale_value}")
    config_lines+=("")

    for (( channel=0; channel<TOTAL_ADC_CHANNELS; channel++ )); do
        local current_type="${channel_types[channel]}"
        local current_label="${channel_labels[channel]}"

        case "$current_type" in
            tank|temp)
                if [ -n "$current_label" ]; then
                    local formatted_label
                    formatted_label="$(format_label_for_dbus_config "$current_label")"
                    config_lines+=("label ${formatted_label}")
                fi
                config_lines+=("${current_type} ${channel}")
                ;;
            none|"")
                continue
                ;;
            *)
                local channel_display=$((channel + 1))
                unsupported_channels+=("Kanal ${channel_display} (${current_type:-unbekannt})")
                continue
                ;;
        esac
    done

    if [ "${#unsupported_channels[@]}" -gt 0 ]; then
        local unsupported_summary="${unsupported_channels[*]}"
        logMessage "Fehler: Nicht unterstützte Kanaltypen in der Konfiguration: ${unsupported_summary}."
        setInstallFailed $EXIT_ERROR "Nicht unterstützte Kanaltypen (${unsupported_summary})."
        return 1
    fi

    if [ "$check_mode" = true ]; then
        logMessage "CHECK-Modus: Konfiguration erfolgreich validiert – keine Dateien wurden geändert."
        return 0
    fi

    local temp_config
    if ! temp_config="$(mktemp)"; then
        logMessage "Fehler: Konnte temporäre Datei für dbus-adc.conf nicht erstellen."
        setInstallFailed $EXIT_ERROR "mktemp für dbus-adc.conf fehlgeschlagen."
        return 1
    fi

    printf '%s\n' "${config_lines[@]}" > "$temp_config"

    local config_changed=true
    local dbus_config_copied=false
    if [ -f "$CONFIG_FILE" ] && cmp -s "$temp_config" "$CONFIG_FILE"; then
        config_changed=false
        logMessage "dbus-adc.conf ist bereits aktuell; keine Änderungen erforderlich."
    else
        if cp "$temp_config" "$CONFIG_FILE"; then
            logMessage "dbus-adc.conf mit den neuen Werten geschrieben."
            filesUpdated=true
            dbus_config_copied=true
        else
            logMessage "Fehler beim Schreiben der dbus-adc.conf."
            setInstallFailed $EXIT_ERROR "Fehler beim Schreiben der dbus-adc.conf."
            rm -f "$temp_config"
            return 1
        fi
    fi

    rm -f "$temp_config"

    local escaped_vref=""
    local escaped_scale=""
    local escaped_device=""

    escaped_vref="$(escape_for_shell_assignment "$vref_value")"
    escaped_scale="$(escape_for_shell_assignment "$scale_value")"
    escaped_device="$(escape_for_shell_assignment "$device_value")"

    if ! {
        printf 'USER_VREF=%s\n' "$escaped_vref"
        printf 'USER_SCALE=%s\n' "$escaped_scale"
        printf 'USER_DEVICE=%s\n' "$escaped_device"
        for (( channel=0; channel<TOTAL_ADC_CHANNELS; channel++ )); do
            local value="${channel_labels[channel]}"
            local type_value="${channel_types[channel]}"
            type_value="$(canonicalize_sensor_type "$type_value")"
            channel_types[channel]="$type_value"
            local escaped_value
            local escaped_type
            escaped_value="$(escape_for_shell_assignment "$value")"
            escaped_type="$(escape_for_shell_assignment "$type_value")"
            printf 'USER_CHANNEL_%d=%s\n' "$channel" "$escaped_value"
            printf 'USER_CHANNEL_%d_TYPE=%s\n' "$channel" "$escaped_type"
            printf 'USER_CHANNEL_%d_LABEL=%s\n' "$channel" "$escaped_value"
        done
    } > "$USER_CONFIG_FILE"; then
        logMessage "Fehler beim Schreiben der Benutzerkonfiguration nach ${USER_CONFIG_FILE}."
        setInstallFailed $EXIT_ERROR "Fehler beim Schreiben der Benutzerkonfiguration (${USER_CONFIG_FILE})."
        return 1
    fi

    logMessage "Benutzerkonfiguration unter ${USER_CONFIG_FILE} gespeichert."

    if ! $config_changed; then
        logMessage "Bestehende Konfiguration musste nicht überschrieben werden."
    fi

    logMessage "Aktualisiere $CONFIG_TXT..."
    local config_txt_changed=false
    if ! grep -Eq '^[[:space:]]*dtoverlay=i2c-rtc,ds1307([[:space:],]|$)' "$CONFIG_TXT"; then
        echo "dtoverlay=i2c-rtc,ds1307" >> "$CONFIG_TXT"
        filesUpdated=true
        config_txt_changed=true
        logMessage "dtoverlay=i2c-rtc,ds1307 zu $CONFIG_TXT hinzugefügt."
    fi
    if ! grep -Eq '^[[:space:]]*dtoverlay=mcp3208,spi0-0-present([[:space:],]|$)' "$CONFIG_TXT"; then
        echo "dtoverlay=mcp3208,spi0-0-present" >> "$CONFIG_TXT"
        filesUpdated=true
        config_txt_changed=true
        logMessage "dtoverlay=mcp3208,spi0-0-present zu $CONFIG_TXT hinzugefügt."
    fi

    if [ "$config_txt_changed" = true ]; then
        logMessage "$CONFIG_TXT aktualisiert."
    else
        logMessage "$CONFIG_TXT unverändert."
    fi

    if [ "$config_changed" = true ] || [ "$config_txt_changed" = true ]; then
        rebootNeeded=true
        local restart_reason="Konfigurationsdateien geändert"
        if [ "$config_changed" = true ] && [ "$config_txt_changed" != true ]; then
            restart_reason="dbus-adc.conf geändert"
        elif [ "$config_changed" != true ] && [ "$config_txt_changed" = true ]; then
            restart_reason="$CONFIG_TXT geändert"
        elif [ "$config_changed" = true ] && [ "$config_txt_changed" = true ]; then
            restart_reason="dbus-adc.conf und $CONFIG_TXT geändert"
        fi
        logMessage "Neustartbedarf gesetzt, da ${restart_reason}."
    else
        logMessage "Neustart nicht erforderlich: dbus-adc.conf und $CONFIG_TXT blieben unverändert."
    fi
}

# Konfigurationsdateien deinstallieren
uninstall_config() {
    logMessage "Entferne Konfigurationsdateien..."
    if [ "$configTxtRestorePerformed" = true ]; then
        logMessage "config.txt stammt aus der Sicherung; manuelle Bereinigung nicht erforderlich."
    else
        logMessage "Bereinige config.txt manuell, da keine Sicherung wiederhergestellt werden konnte."
        sed -i '/dtoverlay=i2c-rtc,ds1307/d' "$CONFIG_TXT"
        sed -i '/dtoverlay=mcp3208,spi0-0-present/d' "$CONFIG_TXT"
        logMessage "dtoverlay-Einträge wurden manuell aus der config.txt entfernt."
    fi

    prune_legacy_rc_local_entries
    remove_entry_from_rc_local "$RC_LOCAL_HW_CLOCK_ENTRY"

    local backup_file_present=false
    [ -f "$BACKUP_CONFIG_FILE" ] && backup_file_present=true

    if [ "$configRestorePerformed" = true ]; then
        if [ -f "$CONFIG_FILE" ]; then
            logMessage "Originale dbus-adc.conf wurde wiederhergestellt und bleibt erhalten."
        else
            logMessage "Warnung: Wiederhergestellte dbus-adc.conf wurde nicht gefunden."
        fi

        if [ "$backup_file_present" = true ]; then
            logMessage "Sicherungsdatei dbus-adc.conf.orig ist weiterhin vorhanden."
        else
            logMessage "Sicherungsdatei dbus-adc.conf.orig wurde bereits entfernt."
        fi
    else
        if [ "$backup_file_present" = true ]; then
            logMessage "Sicherungsdatei dbus-adc.conf.orig ist vorhanden, konnte jedoch nicht wiederhergestellt werden."
        else
            logMessage "Keine Sicherung der dbus-adc.conf verfügbar; entferne Setup-Version."
        fi

        if [ -f "$CONFIG_FILE" ]; then
            if rm -f "$CONFIG_FILE"; then
                logMessage "dbus-adc.conf aus dem Setup wurde entfernt."
            else
                logMessage "Fehler beim Entfernen der dbus-adc.conf."
                setInstallFailed $EXIT_ERROR "Fehler beim Entfernen der dbus-adc.conf."
            fi
        else
            logMessage "dbus-adc.conf war nicht vorhanden und musste nicht entfernt werden."
        fi
    fi

    logMessage "Konfigurationsdateien deinstalliert."
}

## Overlays prüfen und wiederherstellen bzw. entfernen
# Overlays prüfen und wiederherstellen
check_and_restore_overlays() {
    if is_check_mode; then
        logMessage "CHECK-Modus: Überspringe Wiederherstellung von Device-Tree-Overlays."
        return 0
    fi

    logMessage "Prüfe und stelle Overlays wieder her..."
    for overlay in "${OVERLAYS[@]}"; do
        local overlay_path="$OVERLAY_DIR/$overlay"
        local source_overlay="$SOURCE_FILE_DIR/overlays/$overlay"
        local state_file="$OVERLAY_STATE_DIR/${overlay}.state"
        local timestamp="$(date -u +"%Y-%m-%dT%H:%M:%SZ")"

        if [ ! -f "$source_overlay" ]; then
            logMessage "Fehler: Quelle für Overlay $overlay nicht gefunden."
            setInstallFailed $EXIT_FILE_SET_ERROR "Fehler: Quelle für Overlay $overlay nicht gefunden."
            continue
        fi

        local installed_by_setup_state
        installed_by_setup_state="$(get_overlay_state_value "$state_file" "installed_by_setup")"
        local original_state
        original_state="$(get_overlay_state_value "$state_file" "original")"

        local overlay_present=false
        if [ -f "$overlay_path" ]; then
            overlay_present=true
        fi

        local source_checksum=""
        local checksum_available=false
        if command -v sha256sum >/dev/null 2>&1; then
            source_checksum="$(sha256sum "$source_overlay" | awk '{print $1}')"
            checksum_available=true
        fi

        local checksums_differ=false
        local current_checksum=""
        if [ "$overlay_present" = true ]; then
            if [ "$checksum_available" = true ]; then
                current_checksum="$(sha256sum "$overlay_path" | awk '{print $1}')"
                if [ "$current_checksum" != "$source_checksum" ]; then
                    checksums_differ=true
                fi
            else
                if ! cmp -s "$source_overlay" "$overlay_path"; then
                    checksums_differ=true
                fi
            fi
        fi

        local managed_overlay=false
        if [ "${installed_by_setup_state,,}" = "true" ] || [ "$original_state" = "absent" ]; then
            managed_overlay=true
        fi

        local needs_copy=false
        local replacement_reason=""
        if [ "$overlay_present" != true ]; then
            needs_copy=true
            replacement_reason="fehlte"
        elif [ "$managed_overlay" = true ]; then
            needs_copy=true
            if [ "$checksums_differ" = true ]; then
                replacement_reason="verwaltet und veraltet"
            else
                replacement_reason="verwaltetes Overlay wird aktualisiert"
            fi
        elif [ "$checksums_differ" = true ]; then
            needs_copy=true
            replacement_reason="Checksumme weicht ab"
        fi

        if [ "$needs_copy" = true ]; then
            mkdir -p "$OVERLAY_DIR"
            if cp "$source_overlay" "$overlay_path"; then
                local action_label="overlay_installed"
                if [ "$overlay_present" = true ]; then
                    action_label="overlay_refreshed"
                    logMessage "Overlay $overlay wurde ersetzt (${replacement_reason})."
                else
                    logMessage "Overlay $overlay wurde installiert (${replacement_reason})."
                fi
                if [ "$checksum_available" = true ]; then
                    logMessage "Neue Setup-Checksumme für $overlay: $source_checksum"
                    set_overlay_state_value "$state_file" "setup_checksum" "$source_checksum"
                else
                    logMessage "sha256sum nicht verfügbar; Overlay $overlay wurde per Bytevergleich aktualisiert."
                    set_overlay_state_value "$state_file" "setup_checksum" "sha256_unavailable"
                fi
                set_overlay_state_value "$state_file" "setup_recorded_at" "$timestamp"
                set_overlay_state_value "$state_file" "installed_by_setup" "true"
                set_overlay_state_value "$state_file" "last_action" "$action_label"
                rebootNeeded=true
                logMessage "Neustartbedarf gesetzt, da Overlay $overlay aktualisiert wurde."
            else
                logMessage "Fehler beim Wiederherstellen von Overlay $overlay."
                setInstallFailed $EXIT_ERROR "Fehler beim Wiederherstellen von Overlay $overlay."
            fi
        else
            logMessage "Overlay $overlay ist bereits auf dem aktuellen Stand."
            if [ "$checksum_available" = true ]; then
                set_overlay_state_value "$state_file" "setup_checksum" "$source_checksum"
            else
                set_overlay_state_value "$state_file" "setup_checksum" "sha256_unavailable"
            fi
            set_overlay_state_value "$state_file" "setup_recorded_at" "$timestamp"
        fi
    done
}

# Overlays entfernen
remove_overlays() {
    logMessage "Entferne oder stelle Overlays wieder her..."
    for overlay in "${OVERLAYS[@]}"; do
        local overlay_path="$OVERLAY_DIR/$overlay"
        local state_file="$OVERLAY_STATE_DIR/${overlay}.state"
        local backup_file="$OVERLAY_STATE_DIR/${overlay}.orig"
        local absent_marker="$OVERLAY_STATE_DIR/${overlay}.absent"
        local original_state="$(get_overlay_state_value "$state_file" "original")"
        local installed_by_setup="$(get_overlay_state_value "$state_file" "installed_by_setup")"
        local recorded_checksum="$(get_overlay_state_value "$state_file" "original_checksum")"

        local overlay_marked_absent="false"
        if [ -f "$absent_marker" ] || [ "$original_state" = "absent" ]; then
            overlay_marked_absent="true"
        fi

        if [ "$overlay_marked_absent" = "true" ] && [ "$installed_by_setup" = "true" ]; then
            if [ -f "$overlay_path" ]; then
                if rm -f "$overlay_path"; then
                    logMessage "Overlay $overlay (vom Setup bereitgestellt) wurde entfernt, da es ursprünglich fehlte."
                    rebootNeeded=true
                    logMessage "Neustartbedarf gesetzt, da Overlay $overlay entfernt wurde."
                    set_overlay_state_value "$state_file" "last_action" "removed_setup_overlay"
                else
                    logMessage "Fehler beim Entfernen von Overlay $overlay."
                    setInstallFailed $EXIT_ERROR "Fehler beim Entfernen von Overlay $overlay."
                fi
            else
                logMessage "Overlay $overlay war bereits entfernt; keine Aktion erforderlich."
                set_overlay_state_value "$state_file" "last_action" "already_absent"
            fi
            rm -f "$backup_file"
            set_overlay_state_value "$state_file" "installed_by_setup" "false"
            continue
        fi

        if [ -f "$backup_file" ]; then
            if cp "$backup_file" "$overlay_path"; then
                logMessage "Overlay $overlay wurde auf den ursprünglichen Zustand zurückgesetzt (Checksumme: ${recorded_checksum:-unbekannt})."
                rebootNeeded=true
                logMessage "Neustartbedarf gesetzt, da Overlay $overlay aus der Sicherung wiederhergestellt wurde."
                set_overlay_state_value "$state_file" "installed_by_setup" "false"
                set_overlay_state_value "$state_file" "last_action" "restored_from_backup"
                rm -f "$absent_marker"
            else
                logMessage "Fehler beim Wiederherstellen von Overlay $overlay aus der Sicherung."
                setInstallFailed $EXIT_ERROR "Fehler beim Wiederherstellen von Overlay $overlay aus der Sicherung."
            fi
        else
            if [ "$installed_by_setup" = "true" ] && [ -f "$absent_marker" ]; then
                if [ -f "$overlay_path" ]; then
                    if rm -f "$overlay_path"; then
                        logMessage "Overlay $overlay (vom Setup bereitgestellt) wurde entfernt, da es ursprünglich fehlte."
                        rebootNeeded=true
                        logMessage "Neustartbedarf gesetzt, da Overlay $overlay entfernt wurde."
                        set_overlay_state_value "$state_file" "last_action" "removed_setup_overlay"
                    else
                        logMessage "Fehler beim Entfernen von Overlay $overlay."
                        setInstallFailed $EXIT_ERROR "Fehler beim Entfernen von Overlay $overlay."
                    fi
                else
                    logMessage "Overlay $overlay war bereits entfernt; keine Aktion erforderlich."
                    set_overlay_state_value "$state_file" "last_action" "already_absent"
                fi
                set_overlay_state_value "$state_file" "installed_by_setup" "false"
            else
                if [ -f "$overlay_path" ]; then
                    if [ "$original_state" = "present" ]; then
                        logMessage "Overlay $overlay bleibt unverändert, da es nicht vom Setup verwaltet wurde."
                    else
                        logMessage "Overlay $overlay bleibt bestehen; keine Sicherung oder Setup-Verwaltung vorhanden."
                    fi
                    set_overlay_state_value "$state_file" "last_action" "left_untouched"
                else
                    logMessage "Overlay $overlay ist nicht vorhanden; keine Aktion erforderlich."
                    set_overlay_state_value "$state_file" "last_action" "not_present"
                fi
            fi
        fi
    done
    logMessage "Overlay-Verarbeitung abgeschlossen."
}

## Kernel-Module prüfen und installieren bzw. deinstallieren
# Kernel-Module prüfen, ohne Änderungen vorzunehmen
check_kernel_module_dependencies() {
    local -n _missing_modules="$1"
    local -n _present_modules="$2"

    _missing_modules=()
    _present_modules=()

    local module
    for module in "${REQUIRED_MODULES[@]}"; do
        if opkg list-installed | awk '{print $1}' | grep -Fxq "$module"; then
            _present_modules+=("$module")
        else
            _missing_modules+=("$module")
        fi
    done

    if [ "${#_missing_modules[@]}" -eq 0 ]; then
        return 0
    fi

    return 1
}

# Kernel-Module prüfen und installieren
check_and_install_kernel_modules() {
    logMessage "Prüfe und installiere Kernel-Module..."
    local -a missing_modules=()
    local -a present_modules=()
    local -a newly_installed=()

    check_kernel_module_dependencies missing_modules present_modules

    local module
    for module in "${present_modules[@]}"; do
        logMessage "$module ist bereits installiert und bleibt unverändert."
    done

    if [ ${#missing_modules[@]} -eq 0 ]; then
        return
    fi

    if is_check_mode; then
        logMessage "CHECK-Modus: Fehlende Kernel-Module erkannt: ${missing_modules[*]}."
        setInstallFailed $EXIT_ERROR "Fehlende Kernel-Module: ${missing_modules[*]}"
        return 1
    fi

    if [ "$OPKG_UPDATE_PERFORMED" != "true" ]; then
        logMessage "Aktualisiere Paketquellen..."
        if ! opkg update; then
            logMessage "Fehler bei der Aktualisierung der Paketquellen."
            setInstallFailed $EXIT_ERROR "Fehler bei der Aktualisierung der Paketquellen."
            return
        fi
        OPKG_UPDATE_PERFORMED=true
    else
        logMessage "Paketquellen bereits aktualisiert; überspringe erneutes opkg update."
    fi

    for module in "${missing_modules[@]}"; do
        logMessage "Installiere $module..."
        if opkg install "$module"; then
            logMessage "$module installiert."
            rebootNeeded=true
            if [ ! -d "$MODULE_STATE_DIR" ]; then
                mkdir -p "$MODULE_STATE_DIR"
            fi
            if [ ! -f "$MODULE_TRACK_FILE" ]; then
                : > "$MODULE_TRACK_FILE"
            fi
            if ! grep -Fxq "$module" "$MODULE_TRACK_FILE"; then
                echo "$module" >> "$MODULE_TRACK_FILE"
                logMessage "$module wurde für eine spätere Deinstallation markiert."
            else
                logMessage "$module war bereits als durch das Setup installiert markiert."
            fi
            newly_installed+=("$module")
        else
            logMessage "Fehler bei der Installation von $module."
            setInstallFailed $EXIT_ERROR "Fehler bei der Installation von $module."
        fi
    done

    if [ ${#newly_installed[@]} -gt 0 ]; then
        logMessage "Neu installierte Kernel-Module: ${newly_installed[*]}"
    else
        logMessage "Keine neuen Kernel-Module erforderlich; bestehende Installationen bleiben erhalten."
    fi
}

# Kernel-Module deinstallieren
remove_kernel_modules() {
    logMessage "Entferne Kernel-Module, die vom Setup installiert wurden..."

    if [ ! -f "$MODULE_TRACK_FILE" ]; then
        for module in "${REQUIRED_MODULES[@]}"; do
            logMessage "Modul $module wurde nicht zum Entfernen markiert und bleibt unverändert."
        done
        logMessage "Keine markierten Kernel-Module gefunden; es wurde nichts entfernt."
        return
    fi

    local marked_modules=()
    mapfile -t marked_modules < "$MODULE_TRACK_FILE"

    local filtered_marked=()
    local entry
    for entry in "${marked_modules[@]}"; do
        if [ -n "$entry" ]; then
            filtered_marked+=("$entry")
        fi
    done
    marked_modules=("${filtered_marked[@]}")

    if [ ${#marked_modules[@]} -eq 0 ]; then
        for module in "${REQUIRED_MODULES[@]}"; do
            logMessage "Modul $module wurde nicht zum Entfernen markiert und bleibt unverändert."
        done
        logMessage "Die Markierungsliste ist leer; es wurde nichts entfernt."
        return
    fi

    local removed_modules=()
    local failed_removals=()
    local already_absent_modules=()

    for module in "${marked_modules[@]}"; do
        if opkg list-installed | awk '{print $1}' | grep -Fxq "$module"; then
            logMessage "Entferne markiertes Modul $module..."
            if opkg remove "$module"; then
                logMessage "$module entfernt."
                removed_modules+=("$module")
                rebootNeeded=true
            else
                logMessage "Fehler beim Entfernen von $module."
                setInstallFailed $EXIT_ERROR "Fehler beim Entfernen von $module."
                failed_removals+=("$module")
            fi
        else
            logMessage "Markiertes Modul $module ist nicht installiert und bleibt unverändert."
            already_absent_modules+=("$module")
        fi
    done

    if [ ${#removed_modules[@]} -gt 0 ] || [ ${#already_absent_modules[@]} -gt 0 ]; then
        local remaining_marked=()
        for module in "${marked_modules[@]}"; do
            local remove_entry=0
            for removed in "${removed_modules[@]}"; do
                if [ "$module" = "$removed" ]; then
                    remove_entry=1
                    break
                fi
            done
            if [ "$remove_entry" -eq 0 ]; then
                local missing_entry=0
                for missing in "${already_absent_modules[@]}"; do
                    if [ "$module" = "$missing" ]; then
                        missing_entry=1
                        break
                    fi
                done
                if [ "$missing_entry" -eq 0 ]; then
                    remaining_marked+=("$module")
                fi
            fi
        done

        if [ ${#remaining_marked[@]} -gt 0 ]; then
            printf '%s\n' "${remaining_marked[@]}" > "$MODULE_TRACK_FILE"
        else
            rm -f "$MODULE_TRACK_FILE"
        fi
    fi

    if [ ${#removed_modules[@]} -gt 0 ]; then
        logMessage "Folgende markierte Module wurden entfernt: ${removed_modules[*]}"
    else
        logMessage "Es wurden keine markierten Module entfernt."
    fi

    if [ ${#already_absent_modules[@]} -gt 0 ]; then
        logMessage "Folgende markierte Module waren bereits nicht installiert: ${already_absent_modules[*]}"
    fi

    if [ ${#failed_removals[@]} -gt 0 ]; then
        logMessage "Folgende markierte Module konnten nicht entfernt werden und bleiben installiert: ${failed_removals[*]}"
    fi

    local unmarked_modules=()
    for module in "${REQUIRED_MODULES[@]}"; do
        local is_marked=0
        for marked in "${marked_modules[@]}"; do
            if [ "$module" = "$marked" ]; then
                is_marked=1
                break
            fi
        done
        if [ "$is_marked" -eq 0 ]; then
            unmarked_modules+=("$module")
        fi
    done

    if [ ${#unmarked_modules[@]} -gt 0 ]; then
        logMessage "Folgende Module wurden nicht zum Entfernen markiert und bleiben erhalten: ${unmarked_modules[*]}"
    fi
}

## rc.local einrichten und zurücksetzen
# rc.local einrichten
setup_rc_local() {
    if is_check_mode; then
        logMessage "CHECK-Modus: rc.local wird nicht verändert."
        return 0
    fi

    logMessage "Richte rc.local ein..."
    prune_legacy_rc_local_entries
    add_entry_to_rc_local "$RC_LOCAL_HW_CLOCK_ENTRY"
}

# rc.local zurücksetzen
reset_rc_local() {
    logMessage "Setze rc.local zurück..."
    if [ ! -f "$RC_LOCAL_FILE" ]; then
        logMessage "rc.local ist nicht vorhanden; es wurden keine Änderungen vorgenommen."
        return
    fi

    if [ "$rcLocalRestorePerformed" = true ]; then
        logMessage "rc.local wurde bereits unverändert aus der Sicherung übernommen; keine weitere Bereinigung erforderlich."
        return
    fi

    prune_legacy_rc_local_entries

    local entries=(
        "$RC_LOCAL_HW_CLOCK_ENTRY"
    )
    local backup_exists=false
    if [ "$rcLocalBackupAvailable" = true ] || [ -f "$RC_LOCAL_BACKUP" ]; then
        backup_exists=true
    fi

    if [ "$backup_exists" = true ]; then
        logMessage "Sicherung der rc.local ist vorhanden; vergleiche mit bekannten Setup-Einträgen."
    else
        logMessage "Keine Sicherung der rc.local verfügbar; nutze Setup-Markierungen zur Bereinigung."
    fi

    local removed_entries=()
    local kept_entries=()
    local absent_entries=()

    local entry
    for entry in "${entries[@]}"; do
        if ! grep -qF -- "$entry" "$RC_LOCAL_FILE"; then
            logMessage "rc.local Eintrag \"$entry\" ist nicht vorhanden; keine Aktion erforderlich."
            absent_entries+=("$entry")
            continue
        fi

        local present_in_backup=0
        if [ "$backup_exists" = true ] && grep -qF -- "$entry" "$RC_LOCAL_BACKUP"; then
            present_in_backup=1
        fi

        local marked_by_setup=0
        if [ -f "$RC_LOCAL_STATE_FILE" ] && grep -qFx -- "$entry" "$RC_LOCAL_STATE_FILE"; then
            marked_by_setup=1
        fi

        if [ "$present_in_backup" -eq 1 ]; then
            logMessage "rc.local Eintrag \"$entry\" bleibt bestehen, da er bereits in der Sicherung enthalten war."
            kept_entries+=("$entry")
            continue
        fi

        local removal_reasons=()
        local removal_allowed=false
        if [ "$backup_exists" = false ]; then
            removal_allowed=true
            removal_reasons+=("keine Sicherung verfügbar")
        fi
        if [ "$marked_by_setup" -eq 1 ]; then
            removal_allowed=true
            removal_reasons+=("Setup-Markierung")
        fi
        if [ "$backup_exists" = true ] && [ "$present_in_backup" -eq 0 ]; then
            removal_allowed=true
            removal_reasons+=("nicht in Sicherung enthalten")
        fi

        if [ "$removal_allowed" = true ]; then
            remove_entry_from_rc_local "$entry"
            local removal_reason="${removal_reasons[0]}"
            if [ ${#removal_reasons[@]} -gt 1 ]; then
                local reason_index
                for reason_index in "${removal_reasons[@]:1}"; do
                    removal_reason+=", ${reason_index}"
                done
            fi
            logMessage "rc.local Eintrag \"$entry\" wurde entfernt (${removal_reason})."
            removed_entries+=("$entry")
            if [ -f "$RC_LOCAL_STATE_FILE" ]; then
                local escaped_entry
                escaped_entry=$(printf '%s\n' "$entry" | sed 's/[\/&]/\\&/g')
                sed -i "/^${escaped_entry}$/d" "$RC_LOCAL_STATE_FILE"
            fi
        else
            logMessage "rc.local Eintrag \"$entry\" bleibt bestehen, da kein Nachweis für eine Setup-Herkunft vorliegt."
            kept_entries+=("$entry")
        fi
    done

    if [ -f "$RC_LOCAL_STATE_FILE" ] && [ ! -s "$RC_LOCAL_STATE_FILE" ]; then
        rm -f "$RC_LOCAL_STATE_FILE"
    fi

    if [ ${#removed_entries[@]} -gt 0 ]; then
        logMessage "Folgende rc.local Einträge wurden entfernt: ${removed_entries[*]}"
        logMessage "rc.local wurde gezielt um Setup-Einträge bereinigt."
    else
        logMessage "Es wurden keine rc.local Einträge entfernt."
        logMessage "rc.local blieb nach der Prüfung unverändert."
    fi

    if [ ${#kept_entries[@]} -gt 0 ]; then
        logMessage "Folgende rc.local Einträge blieben erhalten: ${kept_entries[*]}"
    fi

    if [ ${#absent_entries[@]} -gt 0 ]; then
        logMessage "Folgende erwartete rc.local Einträge waren bereits entfernt: ${absent_entries[*]}"
    fi
}

run_uninstall_sequence() {
    restore_originals
    uninstall_config
    remove_overlays
    remove_kernel_modules
    reset_rc_local
    cleanup_executed=true
}

run_prechecks() {
    logMessage "Starte Vorprüfungen..."

    if is_check_mode; then
        if ! validate_backup_prerequisites; then
            return 1
        fi
    else
        if ! backup_originals; then
            return 1
        fi
    fi

    local default_vref=""
    local default_scale=""
    local default_device=""
    local -a default_channel_types=()
    local -a default_channel_labels=()
    load_default_adc_defaults default_vref default_scale default_channel_types default_channel_labels default_device

    local -a present_modules=()
    local -a missing_modules=()
    check_kernel_module_dependencies missing_modules present_modules

    if [ "${#missing_modules[@]}" -gt 0 ]; then
        logMessage "Fehlende Kernel-Module erkannt: ${missing_modules[*]}."
        if is_check_mode; then
            setInstallFailed $EXIT_ERROR "Fehlende Kernel-Module: ${missing_modules[*]}"
            return 1
        fi
        logMessage "Installationsmodus: Fehlende Kernel-Module werden im Anschluss installiert."
    else
        logMessage "Alle erforderlichen Kernel-Module sind bereits installiert."
    fi

    return 0
}

has_install_failed_flag() {
    if declare -F isInstallFailed >/dev/null 2>&1; then
        if isInstallFailed; then
            return 0
        fi
    else
        case "${installFailed:-}" in
            1|true|yes|y|on|fail|failed)
                return 0
                ;;
        esac
        if [ -n "${installFailReason:-}" ]; then
            return 0
        fi
    fi

    return 1
}

should_abort_installation() {
    if [ "${scriptAction:-}" = "UNINSTALL" ]; then
        return 0
    fi

    if has_install_failed_flag; then
        return 0
    fi

    return 1
}

log_install_abort_reason_once() {
    if [ "$install_abort_logged" = true ]; then
        return
    fi

    if [ "${scriptAction:-}" = "UNINSTALL" ]; then
        logMessage "Skriptaktion wurde auf UNINSTALL gesetzt – Installationsablauf wird beendet."
    else
        logMessage "installFailed wurde gesetzt – Installationsablauf wird beendet."
    fi

    install_abort_logged=true
}

case "$scriptAction" in
    INSTALL|CHECK)
        if run_prechecks; then
            if [ "$scriptAction" = "CHECK" ]; then
                logMessage "CHECK-Modus abgeschlossen."
            else
                continue_install=true
                if install_config; then
                    if should_abort_installation; then
                        log_install_abort_reason_once
                        continue_install=false
                    fi
                else
                    logMessage "install_config meldete einen Fehler – überspringe weitere Installationsschritte."
                    continue_install=false
                fi

                if [ "$continue_install" = true ]; then
                    if check_and_restore_overlays; then
                        if should_abort_installation; then
                            log_install_abort_reason_once
                            continue_install=false
                        fi
                    else
                        logMessage "check_and_restore_overlays meldete einen Fehler – weitere Installationsschritte werden nicht ausgeführt."
                        continue_install=false
                    fi
                fi

                if [ "$continue_install" = true ]; then
                    if check_and_install_kernel_modules; then
                        if should_abort_installation; then
                            log_install_abort_reason_once
                            continue_install=false
                        fi
                    else
                        logMessage "check_and_install_kernel_modules meldete einen Fehler – weitere Installationsschritte werden nicht ausgeführt."
                        continue_install=false
                    fi
                fi

                if [ "$continue_install" = true ]; then
                    setup_rc_local
                else
                    if should_abort_installation; then
                        log_install_abort_reason_once
                    else
                        logMessage "Installationsablauf wurde vor der rc.local-Konfiguration beendet."
                    fi
                fi
            fi
        else
            logMessage "Vorprüfungen fehlgeschlagen – Installationsschritte werden übersprungen."
        fi
        ;;
    UNINSTALL)
        run_uninstall_sequence
        ;;
    *)
        logMessage "Keine spezifische Aktion angegeben. Führe Standardinstallation durch..."
        if run_prechecks; then
            continue_install=true
            if install_config; then
                if should_abort_installation; then
                    log_install_abort_reason_once
                    continue_install=false
                fi
            else
                logMessage "install_config meldete einen Fehler – überspringe weitere Installationsschritte."
                continue_install=false
            fi

            if [ "$continue_install" = true ]; then
                if check_and_restore_overlays; then
                    if should_abort_installation; then
                        log_install_abort_reason_once
                        continue_install=false
                    fi
                else
                    logMessage "check_and_restore_overlays meldete einen Fehler – weitere Installationsschritte werden nicht ausgeführt."
                    continue_install=false
                fi
            fi

            if [ "$continue_install" = true ]; then
                if check_and_install_kernel_modules; then
                    if should_abort_installation; then
                        log_install_abort_reason_once
                        continue_install=false
                    fi
                else
                    logMessage "check_and_install_kernel_modules meldete einen Fehler – weitere Installationsschritte werden nicht ausgeführt."
                    continue_install=false
                fi
            fi

            if [ "$continue_install" = true ]; then
                setup_rc_local
            else
                if should_abort_installation; then
                    log_install_abort_reason_once
                else
                    logMessage "Installationsablauf wurde vor der rc.local-Konfiguration beendet."
                fi
            fi
        else
            logMessage "Vorprüfungen fehlgeschlagen – Installationsschritte werden übersprungen."
        fi
        ;;
esac

if [ "$cleanup_executed" != true ]; then
    if [ "${scriptAction:-}" = "UNINSTALL" ]; then
        logMessage "UNINSTALL-Aktion erkannt – führe Bereinigungsschritte aus."
        run_uninstall_sequence
    elif [ "${scriptAction:-}" != "CHECK" ] && has_install_failed_flag; then
        logMessage "Installationsfehler erkannt – führe Bereinigung wie im UNINSTALL-Fall aus."
        run_uninstall_sequence
    fi
fi

if [ "${rebootNeeded:-false}" = true ]; then
    if declare -F setRebootRequired >/dev/null 2>&1; then
        logMessage "Neustart erforderlich – melde Bedarf über setRebootRequired."
        setRebootRequired
    else
        logMessage "Warnung: Neustart erforderlich, aber Helper-Funktion setRebootRequired ist nicht verfügbar."
    fi
fi

logMessage "Skriptausführung abgeschlossen."
endScript
